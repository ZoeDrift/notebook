学的好乱，我不管了乱写笔记了  

## 类和对象、构造函数和析构函数
### 函数声明
普通成员函数形式：即在类的声明中只给出成员函数的原型，而成员函数体写在类的外部。  
类内：  
>返回类型 成员函数 (参数列表);  

类外：  
>返回类型 类名::成员函数(参数表)
>{
>    //函数体
>}

### 内联函数和外联函数
内联函数：定义在类体内的成员函数，即该函数的函数体放在类体内。在调用时不是像一般函数那样要转去执行被调用函数的函数体，执行完成后再转回调用函数中，执行其后语句，而是在调用函数处用内联函数体的代码来替换，这样将会节省调用开销，提高运行速度。  

内联函数声明：  
1.隐式声明：直接把函数声明在类里
2.显式声明：类声明中只给出成员函数的原型，而成员函数体写在类的外部。但是外部要在返回类型前加上`inline`   
类外定义形式：  
```cpp
inline 返回类型 类名::成员函数名(参数表)
{
    //函数体
}
```

!!! note
    1.使用inline说明内联函数时，必须使函数体和inline说明结合在一起，否则编译器将它作为普通函数处理。  
        例：inline  void Coord:: setCoord(int ,int);不能说明这是一个内联函数。
    2.通常只有较短的成员函数才定义为内联函数，对较长的成员函数最好作为一般函数处理。  



外联函数:说明在类体内，定义在类体外的成员函数叫外联函数。外联函数的函数体在类的实现部分。 

### 对象
对象的定义类似c中结构，  
1.在声明类的同时，直接定义对象，此时定义难道对象是一种全局对象  
2.声明了类之后，在使用时再定义对象  
3.在定义对象时，若定义的是指向对象的指针，则访问此对象的成员时，要用“->”操作符。  

```cpp
void  main( )
{
Date  *date3;
date3->setDate(2001,8,15);
//……
}
```

类成员的访问属性

* 说明为公有的成员不但可以被类中成员函数访问;还可在类的外部,通过类的对象进行访问。
* 说明为私有的成员只能被类中成员函数访问,不能在类的外部,通过类的对象进行访问。
* 说明为保护的成员除了类本身的成员函数可以访问外,该类的派生类的成员也可以访问,但不能在类的外部,通过类的对象进行访问。
* 类的成员对类对象的可见性和对类的成员函数的可见性是不同的。类的成员函数可以访问类的所有成员，而类的对象对类的成员的访问是受类成员的访问属性的制约的。

类成员的访问方式

* 类中成员互访：直接使用成员名
* 类外访问：使用`对象名.成员名`方式访问public属性的成员


对象赋值：

* 同类型的对象间可以进行赋值，当一个对象赋值给另一个对象时，所有的数据成员都会逐位拷贝。
* 两个对象之间的赋值，仅仅使这些对象中数据成员相同，而两个对象仍是分离的。
* 例2.5(1)的对象赋值是通过缺省的赋值运算符函数实现的。
* 当类中存在指针时，使用缺省的赋值运算符进行对象赋值，可能会产生错误。

!!! note
    缺省的赋值运算符函数（Default Assignment Operator）是什么？  
    当你定义一个类，但 没有自己写赋值运算符 operator= 时，编译器会自动帮你生成一个“缺省”的（默认的）赋值运算符。这个函数长这样：  
    `ClassName& operator=(const ClassName& other);`

类的作用域：  

* 所谓类的作用域就是指在类声明中的一对花括号所形成的作用域。  
* 一个类的所有成员都在该类的作用域内,一个类的任何成员可以访问该类的其他成员。 
* 一个类的成员函数可以不受限制地访问类的成员，而在类的外部，对该类的数据成员和成员函数的访问则要受到一定的限制，有时甚至是不允许的,这体现了类的封装功能。 

### 构造函数
1.类的构造函数是类的一个特殊成员函数，它没有返回类型（void也不行），可以有参数，函数名和类名一样。  
2.当创建类的一个新对象时，自动调用构造函数，完成初始化工作（需要注意构造函数是否有参数，以及参数的个数、类型）。  
3.构造函数是特殊的成员函数,函数体可写在类体内,也可写在类体外  
4.构造函数可以重载,即一个类中可以定义多个参数个数或参数类型不同的构造函数。构造函数是不能继承
5.构造函数被声明为公有函数,但它不能像其他成员函数那样被显式地调用,它是在定义对象的同时被调用的。  
6.在声明类时如果没有定义类的构造函数，编译系统就会在编译时自动生成一个默认形式的构造函数，默认构造函数是构造对象时不提供参数的构造函数。除了无参数构造函数是默认构造函数外，带有全部默认参数值的构造函数也是默认构造函数。
7.自动调用：构造函数在定义类对象时自动调用，不需用户调用，也不能被用户调用。在对象使用前调用。  
8.调用顺序：在对象进入其作用域时（对象使用前）调用构造函数。  

构造函数初始化数据成员的方式：  
1.在构造函数体内用赋值语句的方式
```cpp
Date::Date(int y, int m, int d)
{  year = y; 
   month = m; 
   day = d; 
}
```
2.构造函数的初始化列表的方式
```cpp
Date::Date(int y,int m,int d):year(y), month(m),day(d)
{}
```
类成员是 **按照它们在类里被声明的顺序** 初始化的,与它们在初始化表中列出的顺序无关。  

!!! note "哪些情况必须用初始化列表"
    1.常量成员 const,不能对 const 做赋值，只能在初始化列表里写：```A() : x(10) {}```
    2.引用成员变量 int& r;```A(int& ref) : r(ref) {}```  
    3.成员对象（有自己构造函数的类成员）,必须在初始化列表里指定初始值，否则会产生两次构造（先默认构造，再赋值）。  

利用构造函数创建对象的两种方法:  
1.在栈上-利用构造函数直接创建对象.其一般形式为: ```类名  对象名[(实参表)];``` 这里的“类名”与构造函数名相同,“实参表”是为构造函数提供的实际参数。  
2.在堆上-利用构造函数创建对象时,通过指针和new来实现。其一般语法形式为:```类名 *指针变量 = new 类名[(实参表)];```，需要手动delete。例如： ```Date *date1=new Date(1998,4,28);```  
```cpp
//第二种的例子
void main()
{
	    Date *date1;
            date1=new Date(1998,4,28);     
                      //可合写成:Date *date1=new Date(1998,4,28);
	    cout<<"Date1 output1:"<<endl;
	    date1->showDate();          
	    date1->setDate(2002,11,14); 
	    cout<<"Date1 output2:"<<endl;
	    date1->showDate();          
	    delete date1;
}
```

缺省参数（默认参数）的构造函数  
```cpp
Coord(int a=0,int b=0){ x=a; y=b;}   // 带有缺省参数的构造函数

//或者写成初始化列表
Coord(int a=0, int b=0) : x(a), y(b) {}
```

构造函数的重载：  
1.构造函数重载：在一个类中可以定义多个构造函数，以便对类对象提供不同的初始化的方法，供用户选用。这些构造函数具有相同的名字，而参数的个数或参数的类型不相同（这称为构造函数的重载）  
2.建立对象时只执行其中一个构造函数，并非每个构造函数都被执行。  

```cpp
//定义多个构造参数：
class Student {
public:
    Student() {
        cout << "默认构造函数\n";
    }

    Student(string n) {
        cout << "一个参数构造函数\n";
    }

    Student(string n, int age) {
        cout << "两个参数构造函数\n";
    }
};
```

### 拷贝构造函数 
用于 用一个已经存在的对象 去 初始化另一个对象。  
通过等于号复制对象时，系统会自动调用拷贝构造函数。拷贝构造函数与原来的构造函数实现了函数的重载。  

拷贝构造函数的特点：  
1.因为该函数也是一种构造函数,所以其函数名与类名相同,并且该函数也没有返回值类型。  
2.该函数只有一个参数,并且是同类对象的引用。  
3.每个类都必须有一个拷贝构造函数。默认是一个缺省的拷贝构造函数。  

```cpp
//自定义拷贝构造函数
class 类名
{  public :
       类名（形参）；//构造函数
       类名（类名 &对象名）；//拷贝构造函数
           ...
}；
类名:: 类名（类名 &对象名）//拷贝构造函数的实现
{    函数体    }

//调用缺省的拷贝构造函数

```cpp
#include<iostream.h>
class Coord{
public:
    Coord(int a,int b)
    {  x=a; y=b; cout<<"Using normal constructor\n"; }
    void print(){ cout<<x<<"  "<<y<<endl;}
private:
    int x,y;  };
main()
{   Coord p1(30,40);    // 定义类Coord的对象p1,
                        // 调用了普通构造函数初始化对象p1
     Coord p2(p1);      // 以“代入”法调用缺省的拷贝构造函数,
                        // 用对象p1初始化对象p2
    Coord p3=p1;        // 以“赋值”法调用缺省的拷贝构造函数,
                        // 用对象p1初始化对象p3
    p1.print(); p2.print(); p3.print();
    return 0;
} 
```

调用拷贝函数的三种情况：  
1.当用类的一个对象去初始化该类的另一个对象时。  
2.当函数的形参是类的对象,调用函数,进行形参和实参结合时。  
```cpp
   fun1(Coord p)      // 函数的形参是类的对象
   { 
      p.print();
   }
   main()
  {
    Coord p1(10,20);
    fun1(p1);          // 当调用函数,进行形参和实参结合时,
                              调用拷贝构造函数
    return 0;
  }
```
3.当函数的返回值是对象,函数执行完成,返回调用者时。  
```cpp
Coord fun2()
{    Coord p1(10,30);
    return p1;    }    // 函数的返回值是对象

main()
{    Coord p2;
    P2=fun2(); // 函数执行完成,返回调用者时,调用拷贝构造函数                                  
    return 0;  }
```

**浅拷贝和深拷贝：**  
浅拷贝，就是由缺省的拷贝构造函数所实现的数据成员逐一赋值，若类中含有指针类型数据，则会产生错误。  
有指针必须用深拷贝
```cpp
class A {
    int *p;
public:
    A(int v) { p = new int(v); }

    // 拷贝构造函数 —— 深拷贝
    A(const A& other) {
        p = new int(*other.p);
    }

    ~A() { delete p; }
};
```

1.不管是浅拷贝还是深拷贝，传参都是传引用  
2.在深拷贝时，必须new一块新的堆内存  

### 析构函数
析构函数也是一种特殊的成员函数。它执行与构造函数相反的操作,通常用于撤消对象时的一些清理任务,如释放分配给对象的内存空间等。  

特点：  
1.析构函数与构造函数名字相同,但它前面必须加一个波浪号(~)  
2.析构函数没有参数,也没有返回值,而且不能重载。因此在一个类中只能有一个析构函数;  
3.当撤消对象时,编译系统会自动地调用析构函数。如果程序员没有定义析构函数，系统将自动生成和调用一个默认析构函数，默认析构函数只能释放对象的数据成员所占用的空间，但不包括堆内存空间  

析构函数被调用的两种情况：  
1.若一个对象被定义在一个函数体内，当这个函数结束时，析构函数被自动调用。   
2.若一个对象是使用new运算符动态创建，在使用delete释放时，自动调用析构函数。  

delete的使用：new了什么就delete什么，new[]了什么就delete[]什么  
`new T[n]` -> `delte[] T`  

### 构造函数和析构函数调用的顺序、对象的生存期
一般顺序：调用析构函数的次序正好与调用构造函数的次序相反：最先被调用的构造函数，其对应的（同一对象中的）析构函数最后被调用，而最后被调用的构造函数，其对应的析构函数最先被调用。  

* 局部对象是被定义在一个函数体或程序块内的，它的作用域限定在函数体或程序块内，生存期较短。
    * 局部自动对象(例如在函数中定义的对象)，则在建立对象时调用其构造函数。如果函数被多次调用，则在每次建立对象时都要调用构造函数。在函数调用结束、对象释放时先调用析构函数。
* 静态对象是被定义在一个文件中，它的作用域从定义是起到文件结束时为止。生存期较长。
    * 如果在函数中定义静态局部对象，则只在程序第一次调用此函数建立对象时调用构造函数一次，在调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束或调用exit函数结束程序时，才调用析构函数。
* 全局对象是被定义在某个文件中，它的作用域包含在该文件的整个程序中，生存期是最长的。
    * 在全局范围中定义的对象(即在所有函数之外定义的对象)，它的构造函数在所有函数(包括main函数)执行之前调用。在程序的流程离开其作用域时(如main函数结束或调用exit函数) 时，调用该全局对象的析构函数。
* 动态对象是由程序员掌握的，它的作用域和生存期是由new和delete之间的间隔决定的。

### 类的组合
类中的成员数据是另一个类的对象,可以在已有的抽象的基础上实现更复杂的抽象。  

```cpp
//eg:表示学生和地址的关系
#include <iostream>
#include <string>
using namespace std;

class Address {
public:
    string city;
    string street;

    Address(string c, string s) : city(c), street(s) {}
    void show() {
        cout << city << ", " << street << endl;
    }
};

class Student {
public:
    string name;
    int age;
    Address addr;  // 组合：Student“有一个”Address

    Student(string n, int a, Address ad) : name(n), age(a), addr(ad) {}
    void show() {
        cout << name << ", " << age << " years old, lives at ";
        addr.show();
    }
};

int main() {
    Address a1("Beijing", "Chaoyang Road");
    Student s1("Tom", 20, a1);
    s1.show();
}
//当 Student 对象被销毁时，它内部的 Address 对象也被销毁
```

类组合的构造函数调用：  
1.构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反）  
2.若调用默认构造函数（即无形参的），则内嵌对象的初始化也将调用相应的默认构造函数。  

前向引用声明：  

* 如果需要在某个类的声明之前，引用该类，则应进行前向引用声明。前向引用声明只为程序引入一个标识符，但具体声明在其它地方。  
* 使用前向引用声明虽然可以解决一些问题，但它并不是万能的。需要注意的是，尽管使用了前向引用声明，但是在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象。  
* 应该记住：当你使用前向引用声明时，你 **只能使用被声明的符号** ，而不能涉及类的任何细节。

```cpp
//eg
class B;  //前向引用声明
class A
{  public:
      void f(B b);
};
class B
{  public:
      void g(A a);
};
```

## 类的设计
### 自引用指针this ；
* 每一个类的成员函数都有一个隐藏定义的常量指针，我们把它称为this指针。this指针的类型就是成员函数所属的类的类型。 
* this指针是隐式使用的，它是作为参数被传递给成员函数的。
* 自动实现：是编译系统自动实现的，程序设计者不必人为地在形参中增加this指针，也不必将对象a的地址传给this指针。
* `*this`表示对象当前对象本身（比如说调用了Class类内有学生lihua，this的类型是`Class*`，this是指向lihua的指针，*this就是lihua本身）

```cpp
class Circle
{
private:
    double radius;
public:
    Circle(double radius)  // 参数与数据成员同名时
    {
         this->radius = radius;  // 去掉 this 如何理解？-实际上是 把参数赋值给自己，成员变量根本没被修改
         //this->radius 指的是 类的成员变量 radius
         //radius（右边）指的是 函数参数 radius
    }                                  
    double get_area()
    {
        return 3.14 * radius * radius;
    }
};
int main()
{
    Circle c = Circle(1);
    double a = c.get_area();
    cout << a << endl;
    return 0;
}
```

!!! note
    上面这个例子也可以使用初始化列表写
    ```Circle(double radius) : radius(radius) {}  // 左边是成员变量，右边是参数```
### 对象数组与对象指针；
对象数组：每一数组元素都是对象的数组，也就是说，若一个类有若干个对象，则把这一系列的对象用一个数组来存放。对象数组的元素是对象，不仅具有数据成员，而且还有函数成员。  
```类名 数组名[下标表达式]; ```  

与基本数据类型的数组一样,在使用对象数组时也只能访问单个数组元素,也就是一个对象,通过这个对象,也可以访问到它的公有成员,一般形式是:```数组名[下标].成员名```   

如果需要建立某个类的对象数组，在设计类的构造函数时就要充分考虑到数组元素初始化的需要；  
当各个元素的初值要求为相同的值时，应该在类中定义出不带参数的构造函数或带缺省参数值的构造函数；  
当各元素对象的初值要求为不同的值时需要定义带形参(无缺省值)的构造函数。
定义对象数组时，可通过初始化表进行赋值。  

```cpp
#include<iostream.h>
	class exam{
	public:
	    exam()
	     { x=123;}
	    exam(int n)
	     { x=n;}
	    int get_x()
	     { return x; }
	private:
    int x;  
	};
main()
	{  exam ob1[4]={11,22,33,44};   
	    exam ob2[4]={55,66};   
          exam ob3[4]={exam(11),exam(22),exam(33),exam(44)};  
	    exam ob4[4]={exam(55),exam(66)};  
	    ob4[2]=exam(77);
	    ob4[3]=exam(88);   
	    int i;
	    for (i=0;i<4;i++)
	        cout<<ob1[i].get_x()<<' ';
	    cout<<endl;
	    for (i=0;i<4;i++)
	        cout<<ob2[i].get_x()<<' ';
	    cout<<endl;
	    for (i=0;i<4;i++)
            cout<<ob3[i].get_x()<<' ';
          cout<<endl;
          for (i=0;i<4;i++)
             cout<<ob4[i].get_x()<<' ';
	    cout<<endl;  
         return 0;    
}
```
对象指针  
每一个对象在初始化后都会在内存中占有一定的空间。因此，即可以通过对象名访问一个对象，也可以通过对象地址来访问一个对象。对象指针就是用于存放对象地址的变量。声明对象指针的一般语法形式为:```类名* 对象指针名;```  

1.用指针访问单个对象成员  
```cpp
  #include<iostream.h>
class exe{
public:
    void set_a(int a){ x=a; }
    void show_a(){ cout<<x<<endl; }
private:
    int x;
};
main()
{  
    exe ob,*p;     // 声明类exe的对象ob和类exe的对象指针p
    ob.set_a(2);
    ob.show_a();       // 利用对象名访问对象的成员
    p=&ob;             // 将对象ob的地址赋给对象指针p
    p->show_a();       // 利用对象指针访问对象的成员
    return 0;	
} 
//结果
//2
//2
```
2.用对象指针访问对象数组 
将对象数组的首地址赋给对象指针
```cpp
main()
{  exe ob[2],*p;
  ob[0].set_a(10);
      ob[1].set_a(20);
      p=ob;
   p->show_a();
   p++;
   p->show_a();
   return 0;
}
//结果：10 20

```

**指向类的成员的指针**  
类的成员自身也是一些变量、函数或者对象等。因此，也可以直接将它们的地址存放到一个指针变量中，这样就可以使指针直接指向对象的成员，进而可以通过指针访问对象的成员。  

* 指向成员的指针只能访问公有数据成员和成员函数。
* 使用要先声明，再赋值，然后访问。

1.指向数据成员的指针  
```cpp
//声明：类型说明符 类名:: *数据成员指针名；
//赋值：数据成员指针名＝&类名:: 数据成员名
//使用：对象名. *数据成员指针名
//            对象指针名-> *数据成员指针名
#include<iostream.h>
class A{
public:
    A(int i)    {  z=i;  }
    int z;
};
void main(){ 
    A ob(5);
    A *pc1;        	// 声明一个对象指针pc1
    pc1=&ob;         	// 给对象指针pc1赋值
    int A∷*pc2;     // 声明一个数据成员指针pc2  // ①
    pc2=&A∷z;     // 给数据成员指针pc2赋值    // ②
    cout<<ob.*pc2<<endl;        // 用成员指针pc2访问数据成员z
    cout<<pc1->*pc2<<endl;    // 用成员指针pc2访问数据成员z 
    cout<<ob.z<<endl;     	      // 使用对象名访问数据成员z
}

```

2.指向成员函数的指针
```cpp
//声明：类型说明符  (类名∷ *指针名)(参数表); 
//赋值：成员函数指针名 = 类名∷成员函数名; 
//使用：(对象名.*成员函数指针名)(参数表)  ;
//     （对象指针名 -> *成员函数指针名）(参数表) ;
#include<iostream.h>
class Coord {
public:
      Coord(int a=0,int b=0)  { x=a; y=b; }
	 int getx()  { return x; }
	 int gety()  { return y; }
private:
    int x,y;  };
void main() 
{   Coord op(5,6);   
    Coord *pc1=&op; 
    int (Coord∷*pc_getx)();  
    pc_getx=Coord∷getx; 
    cout<<pc1->getx()<<endl; 
    cout<<op.getx()<<endl; 
    cout<<(op.*pc_getx)()<<endl;
    cout<<(pc1->*pc_getx)()<<endl;  
}

```

### 向函数传递对象；
使用对象作为函数参数：  
对象可以作为参数传递给函数，其方法与传递其他类型的数据相同。在向函数传递对象时，是通过传值调用传递给函数的。因此，函数中对对象的任何修改均不影响调用该函数的对象本身。  

```cpp
#include<iostream.h>
class aClass{
 public:
        aClass(int n) { i=n; }
        void set(int n){ i=n; }
        int get( ){ return i; }
private:
        int i; };
void sqr(aClass ob)
{ ob.set(ob.get()*ob.get());
   cout<<"copy of obj has i value of ";
   cout<<ob.get()<<"\n"; }
main()
{ aClass  obj(10);
   sqr(obj);  
   cout<<"But, obj.i is unchanged in main:";
   cout<<obj.get( );    return 0;  } 
```

使用对象指针作为函数参数：  
对象指针可以作为函数的参数，使用对象指针作为函数参数可以实现传址调用，即可在被调用函数中改变调用函数的参数对象的值，实现函数之间的信息传递。同时使用对象指针实参仅将对象的地址值传给形参，而不进行副本的拷贝，这样可以提高运行效率，减少时空开销。  
当函数的形参是对象指针时，调用函数的对应实参应该是某个对象的地址值。（取址就行，不需要再写一个指针，把指针传进去）  

```cpp
#include<iostream.h>
class aClass {
  public:
     aClass(int n) { i=n; }
     void set(int n){ i=n; }
      int get(){ return i;}
  private:
     int i; };
  void sqr(aClass  *ob)
    { ob->set(ob->get() * ob->get());
       cout<<"Copy of obj has i value of ";
       cout<<ob->get()<<"\n"; }
main()
 {  aClass obj(10);
    sqr(&obj);
   cout<<"Now, obj.i in main() has been changed :";
  cout<<obj.get() <<"\n";  return 0;  
} 
```

使用对象引用作为函数参数：  
使用对象引用作为函数参数不但具有用对象指针作函数参数的优点，而且用对象引用作函数参数将更简单、更直接。  
```cpp
//...
void sqr(aClass& ob)
{   ob.set(ob.get() * ob.get());
     cout<<"Copy of obj has i value of ";
     cout<<ob.get()<<"\n"; }
main()
 { aClass obj(10);
    sqr(obj);
    cout<<"Now, obj.i in main() has been changed :";
    cout<<obj.get() <<"\n";
    return 0;   } 
```


### 静态成员static
引入目的：实现一个类的不同对象之间数据和函数共享  
谁共享：本类所有对象  

静态数据成员 = 所有对象共享的变量  
静态成员函数 = 不需要对象就能调用的函数（只能访问静态数据成员）

* 静态数据成员
    * static关键字
    * 该类的所有对象维护该成员的同一个拷贝
    * 必须在类外定义和初始化，用`::`来指明所属的类
    * 初始化：```<数据类型><类名>∷<静态数据成员名>=<值>；```，初始化时不加该成员的访问权限控制符private，public等。初始化位置：定义对象之前，一般在类定义后，main()前进行。
    * 初始化时使用作用域来标明它所属的类，因此，静态数据成员是类的成员，而不是对象的成员
    * 引用静态数据成员：```<类名>::<静态成员名>```
    * 访问方式（只能访问公有静态数据成员）
        * 用类名访问```类名::静态数成员```
        * 用对象访问```对象名.静态数据成员``` 或 ```对象指针->静态数据成员```
    * 私有静态数据成员不能被类外部函数访问，也不能用对象进行访问。
```cpp
#include<iostream.h>
class myclass
{   public:
    static int i;
    int geti()
     { return i;}
};
int myclass∷i=0; // 初始化,不必在前面加static
main()
{ myclass∷i=200;
    myclass ob1,ob2;
    cout<<"ob1.i="<<ob1.geti()<<endl;
    cout<<"ob2.i="<<ob2.geti()<<endl;
    ob1.i=300;  // 对象进行访问
    cout<<"ob1.i="<<ob1.geti()<<endl;
    cout<<"ob2.i="<<ob2.geti()<<endl;
    return 0;
}
```
* 静态成员函数
    * 类外代码可以使用类名和作用域操作符来调用公有静态成员函数
    * 静态成员函数只能引用属于该类的静态数据成员或静态成员函数。静态成员函数中没有指针this，所以访问非静态数据成员，必须通过参数传递方式得到对象名，通过对象名访问。
    * 使用static关键字声明函数成员。同静态数据成员一样，静态成员函数也属整个类，由同一个类的所有对象共同维护，为这些对象所共享。
    * 定义静态成员函数```static 返回类型 静态成员函数名（参数表）```
    * 使用静态成员函数
        * ```类名::静态成员函数名(实参表)```
        * ```对象. 静态成员函数名(实参表)```
        * ```对象指针->静态成员函数名(实参表)```
    * 静态成员函数可以定义成内嵌的，也可以在类外定义，在类外定义时不能用static前缀。
    * 静态成员函数主要用来访问全局变量或同一个类中的静态数据成员。特别是，当它与静态数据成员一起使用时，达到了对同一个类中对象之间共享数据进行维护的目的。
    * 私有静态成员函数不能被类外部函数和对象访问。

```cpp
#include<iostream.h>
class small_cat {
    public:
    small_cat(double w)
    {   weight=w;
        total_weight+=w;        
        total_number++;  }
    static  void display(small_cat& w)//访问非静态成员	
    { cout<<"The small_cat weights  "<<w.weight<<" kg\n";}
    static void total_disp() //访问静态成员
    {   cout<<total_number<<" small_cat total_weight ";
        cout<<total_weight<<"kg "<<endl;    }
    private:
    double weight;               	
    static double total_weight;   
    static double total_number;  
};
double small_cat∷total_weight=0;	
double small_cat∷total_number=0;

int main()
{   small_cat w1(0.9)，w2(0.8)，w3(0.7);
    small_cat∷display(w1);
    small_cat∷display(w2); 
    small_cat∷display(w3); 
    small_cat∷total_disp(); 
    return 0;
} 

```

通过普通指针访问静态成员：  
就指针该咋用就咋用  

通过指针访问类的静态成员函数
```cpp
//通过指针访问类的静态成员函数
#include<iostream.h>
class myclass {
public:
    myclass()       
      {   ++i;  }
    static int geti()  	
      {   return i;  }//静态成员函数
private:
    static int i;     
};
int myclass::i=0;     	
main()
{  int (*get)()=myclass::geti;  //指针访问静态成员函数
   myclass ob1,ob2,ob3;
   cout<<"myclass∷i="<<(*get)()<<endl; 	//使用指针
   return 0;
}
```

* 静态成员函数可以定义成内嵌的，也可以在类外定义，在类外定义时不能用static前缀。
* 静态成员函数主要用来访问全局变量或同一个类中的静态数据成员。特别是，当它与静态数据成员一起使用时，达到了对同一个类中对象之间共享数据进行维护的目的。
* 私有静态成员函数不能被类外部函数和对象访问。
* 使用静态成员函数的一个原因是，可以用它在建立任何对象之前处理静态数据成员。这是普通成员函数不能实现的。
* 静态成员函数中没有指针this，所以静态成员函数不访问类中的非静态数据成员，若确实需要则只能通过对象名（作为参数）访问

静态成员函数访问非静态数据成员  

```cpp
#include<iostream.h>
class small_cat {
  public:
    small_cat(double w)
    { weight=w;
      total_weight+=w;        
      total_number++;  }
  static  void display(small_cat& w)//访问非静态成员	
       { cout<<"The small_cat weights  "<<w.weight<<" kg\n";}
    static void total_disp() //访问静态成员
       { cout<<total_number<<" small_cat total_weight ";
             cout<<total_weight<<"kg "<<endl;    }
  private:
    double weight;               	
    static double total_weight;   
    static double total_number;  
};
double small_cat∷total_weight=0;	
double small_cat∷total_number=0;	

int main()
{   small_cat w1(0.9)，w2(0.8)，w3(0.7);
    small_cat∷display(w1);
    small_cat∷display(w2); 
    small_cat∷display(w3); 
    small_cat∷total_disp(); 
    return 0;
} 

```

### 友元；
友元可以访问与其有好友关系的类中的私有成员。友元包括友元函数和友元类。  
友元既可以是不属于任何类的一般函数,也可以是另一个类的成员函数,还可以是整个的类。友元函数不是当前类的成员函数，而是独立于当前类的外部函数，但它可以访问该类的所有对象的成员，包括私有、保护和公有成员  
友元函数没有this指针  

<!-- 友元函数的声明：  
位置：当前类体中  
格式：函数名前加```friend```  

友元函数的定义：  
类体外：同一般函数（函数名前不能加 `类名::`）  
类体内：函数名前加`friend`   -->

友元函数的声明和定义  

* 普通友元函数
    * 在类中声明，函数名前加```friend```
    * 在类外定义，同一般函数（函数名前不能加 `类名::`）
* 类 B 的成员函数作为类 A 的友元（授予权限的是A，获得权限的事B）
    * 类 A 声明友元，函数名前加```friend```，加上```B类名::```
    * 类 B 定义成员函数，什么都不加（形参是A类对象的引用）  
    * 类外定义，函数名前加上```B类名::```

友元函数一般带有一个该类的入口参数。因为友元函数不是类的成员函数，它没有this指针，所以它不能直接引用对象成员的名字，也不能通过this指针引用对象的成员，它必须通过作为入口参数传递进来的对象名或对象指针来引用该对象的成员。  

```cpp
// friend functions 
#include <iostream> 
using namespace std; 
class Rectangle { 
	int width, height; 
public: 
	Rectangle() {} 
	Rectangle (int x, int y) : width(x), height(y) {}
 	int area() {return width * height;} 
	friend Rectangle duplicate (const Rectangle&); 
};
Rectangle duplicate (const Rectangle& param) { 
	Rectangle res; 
	res.width = param.width*2; 
	res.height = param.height*2; 
return res; 
} 
int main () { 
	Rectangle foo; 
	Rectangle bar (2,3); 
	foo = duplicate (bar); 
	cout << foo.area() << '\n'; 
	return 0; 
}
```

!!! note "函数声明"
    cpp中的函数声明可以只写参数类型，不写参数名，如```int f(int, float);```

友元函数可以是多个类的    
（注意前向引用）  

友元成员函数不仅可以是一般函数(非成员函数)，而且可以是另一个类中的成员函数  

!!! note "friend"
    友元关系一定写在“授予权限的那个类”里面。哪个类要把自己的`private`交给某个函数访问，就在那个类里写`friend`。  

```cpp
 #include<iostream.h>
#include<string.h>
class girl; //前向引用
class boy {
public:
    boy(char *n,int d)
    {   name=new char[strlen(n)+1];
        strcpy(name,n); age=d; }
    void disp(girl &);         // 声明disp()为类boy的成员函数
    ~boy(){ delete name;  }
private:
    char *name;
    int age;
};
class girl {
public:
    girl(char *n,int d){
        name=new char[strlen(n)+1];
        strcpy(name,n); age=d; }
    friend void boy::disp(girl &); 
    ~girl(){ delete name; }
private:
	char *name;
    int age; };
	void boy::disp(girl &x)
	{   cout<<"Boy\′s name is "<<name<<",age:"<<age<<"\n";
	    cout<<"Girl\′s name is "<<x.name<<",age:"<<x.age<<"\n";}
    void main()
    {   boy b("Chen Hao",25);
        girl e("Zhang Wei ",18);
        b.disp(e);
    }

// 程序运行结果如下:
// Boy′s name is Chen Hao ,age: 25
// Girl′s name is: Zhang Wei ,age: 18 
```

友元类  
不仅可以将一个函数声明为一个类的“朋友”，而且可以将一个类(例如B类)声明为另一个类(例如A类)的“朋友”。这时B类就是A类的友元类。友元类B中的所有函数都是A类的友元函数，可以访问A类中的所有成员。  

```cpp
class  Y {
    //…
};
class X {
     //…
    friend  Y; // 声明类Y为类X的友元类
     //类Y的所有成员函数都是类X的友元函数
     //Y可以访问X的成员

}; 
```

* 友元的关系是单向的而不是双向的。  
* 友元的关系不能传递

!!! note "friend的位置"
    在 C++ 里，友元（friend）声明的位置对功能没影响，也就是：可以写在 private 区域,也可以写在 public 区域  
    friend 本质是 访问权限的授予，不是成员函数或成员变量  


### 对象成员；
如果一个类的对象是另一个类的数据成员,则称这样的数据成员为对象成员。  
```cpp
class A
{
    //'''
};
class B
{
    A a;//类A的对象a为类B的对象成员
    public:
    //...
}
```
### 常类型；
### 多文件组成；

## 继承与派生类
### 继承与派生类
基类（Base class）/父类（Parent class）：被继承的类  
派生类（Derived class）/子类（Child class）：继承基类的类  

继承内容：除构造函数、析构函数、私有成员外的其他成员  
保持已有类的特性而构造新类的过程称为 **继承** 。  
在已有类的基础上新增自己的特性而产生新类的过程称为 **派生** 。  

从已有类派生出新类时,可以在派生类内完成以下几种功能:  

* 可以增加新的数据成员;
* 可以增加新的成员函数;
* 可以重新定义基类中已有的成员函数;、
* 可以改变现有成员的属性。

!!! note "name hiding"
    mark一下。

继承方式和访问权限  

|继承方式|基类 public → 派生类访问|基类 protected → 派生类访问|基类 private → 派生类访问|外部通过派生类对象访问基类成员|
|------|---------|--------|-------|-------|
|public|public|protected|×（hidden）|public 成员可访问，protected ×|
|protected|protected|protected|×（hidden）|外部不可访问|
|private|private|private|×（hidden）|外部不可访问|

声明一个派生类的一般方式

```cpp

class  派生类名:继承方式  基类名 
{
       //派生类新增的数据成员和成员函数
    }; 
```

默认为private私有继承  

什么时候使用`protected`？  
public to all derived classes  
`private`只对自己和友元可见  

### 派生类的构造函数和析构函数
### 多继承
### 赋值兼容规则

### conversion类型转换upcasting
可以创建一个父类的指针或引用，让他指向一个子类的对象。通过指针指向的对象（子类对象）会被当成父类的对象去使用。  

upcasting是多态的前提  

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void eat() { cout << "Animal eats\n"; }
};

class Dog : public Animal {
public:
    void bark() { cout << "Dog barks\n"; }
};

int main() {
    Dog d;              // 子类对象
    Animal* pa = &d;    // 父类指针指向子类对象（upcasting）
    
    pa->eat();           // ✅ 可以调用父类成员
    // pa->bark();       // ❌ 父类指针不能调用子类特有成员
}

//输出:Animal eats
```
1.派生的对象可以赋给基类的对象。
如：(约定derived是从类base公有派生而来的)  
```cpp
derived d;
base b;
b=d;
```

2.派生类的对象可以初始化基类的引用。如：  
```cpp
derive d; 
base &br=d;
```

3.派生类对象的地址可以赋给指向基类的指针，如：  
```cpp
derived d;
base *pb=&d;
```

在后两种情况下，通过指针或引用只能访问对象d中所继承的基类成员。

## 多态性与虚函数

### 多态性polymorphism
所谓 **多态性** 就是不同对象收到相同的消息时，产生不同的动作  

* 多态性的两种描述：
    * 指具有不同功能的函数可以用同一个函数名；
    * 指向不同的对象发送同一个消息，不同的对象在接收时会产生不同的行为；
* 从实现角度看，分为静态多态性和动态多态性
    * 静态多态性——函数重载和运算符重载；
    * 运行时的多态——继承和虚函数；
* 多态的实现：
    * 函数重载；
    * 运算符重载；
    * 虚函数；
* 静态绑定
    * 代码怎么写就绑定什么
* 动态绑定
    * 父类和子类有继承关系、出现虚函数
### 虚函数
虚函数允许函数调用与函数体之间的联系在运行时才建立，也就是在运行时才决定如何动作，即所谓的动态联编。（动态绑定）  

虚函数是动态联编的基础。虚函数是成员函数，而且是非static的成员函数。说明虚函数的方法如下  
```virtual<类型说明符><函数名>(<参数表>)```  
其中，被关键字virtual说明的函数称为虚函数。  

!!! note "写法"
    推荐在父类前面标virtual，在子类加override
### 纯虚函数
### 抽象类
