学的好乱，我不管了乱写笔记了  

## 类和对象、构造函数和析构函数
### 函数声明
普通成员函数形式：即在类的声明中只给出成员函数的原型，而成员函数体写在类的外部。  
类内：  
>返回类型 成员函数 (参数列表);  

类外：  
>返回类型 类名::成员函数(参数表)
>{
>    //函数体
>}

### 内联函数和外联函数
内联函数：定义在类体内的成员函数，即该函数的函数体放在类体内。在调用时不是像一般函数那样要转去执行被调用函数的函数体，执行完成后再转回调用函数中，执行其后语句，而是在调用函数处用内联函数体的代码来替换，这样将会节省调用开销，提高运行速度。  

内联函数声明：  
1.隐式声明：直接把函数声明在类里
2.显式声明：类声明中只给出成员函数的原型，而成员函数体写在类的外部。但是外部要在返回类型前加上`inline`   
类外定义形式：  
```cpp
inline 返回类型 类名::成员函数名(参数表)
{
    //函数体
}
```

!!! note
    1.使用inline说明内联函数时，必须使函数体和inline说明结合在一起，否则编译器将它作为普通函数处理。  
        例：inline  void Coord:: setCoord(int ,int);不能说明这是一个内联函数。
    2.通常只有较短的成员函数才定义为内联函数，对较长的成员函数最好作为一般函数处理。  



外联函数:说明在类体内，定义在类体外的成员函数叫外联函数。外联函数的函数体在类的实现部分。 

### 对象
对象的定义类似c中结构，  
1.在声明类的同时，直接定义对象，此时定义难道对象是一种全局对象  
2.声明了类之后，在使用时再定义对象  
3.在定义对象时，若定义的是指向对象的指针，则访问此对象的成员时，要用“->”操作符。  

```cpp
void  main( )
{
Date  *date3;
date3->setDate(2001,8,15);
//……
}
```

类成员的访问属性

* 说明为公有的成员不但可以被类中成员函数访问;还可在类的外部,通过类的对象进行访问。
* 说明为私有的成员只能被类中成员函数访问,不能在类的外部,通过类的对象进行访问。
* 说明为保护的成员除了类本身的成员函数可以访问外,该类的派生类的成员也可以访问,但不能在类的外部,通过类的对象进行访问。
* 类的成员对类对象的可见性和对类的成员函数的可见性是不同的。类的成员函数可以访问类的所有成员，而类的对象对类的成员的访问是受类成员的访问属性的制约的。

类成员的访问方式

* 类中成员互访：直接使用成员名
* 类外访问：使用`对象名.成员名`方式访问public属性的成员


对象赋值：

* 同类型的对象间可以进行赋值，当一个对象赋值给另一个对象时，所有的数据成员都会逐位拷贝。
* 两个对象之间的赋值，仅仅使这些对象中数据成员相同，而两个对象仍是分离的。
* 例2.5(1)的对象赋值是通过缺省的赋值运算符函数实现的。
* 当类中存在指针时，使用缺省的赋值运算符进行对象赋值，可能会产生错误。

!!! note
    缺省的赋值运算符函数（Default Assignment Operator）是什么？  
    当你定义一个类，但 没有自己写赋值运算符 operator= 时，编译器会自动帮你生成一个“缺省”的（默认的）赋值运算符。这个函数长这样：  
    `ClassName& operator=(const ClassName& other);`

类的作用域：  

* 所谓类的作用域就是指在类声明中的一对花括号所形成的作用域。  
* 一个类的所有成员都在该类的作用域内,一个类的任何成员可以访问该类的其他成员。 
* 一个类的成员函数可以不受限制地访问类的成员，而在类的外部，对该类的数据成员和成员函数的访问则要受到一定的限制，有时甚至是不允许的,这体现了类的封装功能。 

### 构造函数
1.类的构造函数是类的一个特殊成员函数，它没有返回类型（void也不行），可以有参数，函数名和类名一样。  
2.当创建类的一个新对象时，自动调用构造函数，完成初始化工作（需要注意构造函数是否有参数，以及参数的个数、类型）。  
3.构造函数是特殊的成员函数,函数体可写在类体内,也可写在类体外  
4.构造函数可以重载,即一个类中可以定义多个参数个数或参数类型不同的构造函数。构造函数是不能继承
5.构造函数被声明为公有函数,但它不能像其他成员函数那样被显式地调用,它是在定义对象的同时被调用的。  
6.在声明类时如果没有定义类的构造函数，编译系统就会在编译时自动生成一个默认形式的构造函数，默认构造函数是构造对象时不提供参数的构造函数。除了无参数构造函数是默认构造函数外，带有全部默认参数值的构造函数也是默认构造函数。
7.自动调用：构造函数在定义类对象时自动调用，不需用户调用，也不能被用户调用。在对象使用前调用。  
8.调用顺序：在对象进入其作用域时（对象使用前）调用构造函数。  

构造函数初始化数据成员的方式：  
1.在构造函数体内用赋值语句的方式
```cpp
Date::Date(int y, int m, int d)
{  year = y; 
   month = m; 
   day = d; 
}
```
2.构造函数的初始化列表的方式
```cpp
Date::Date(int y,int m,int d):year(y), month(m),day(d)
{}
```
类成员是 **按照它们在类里被声明的顺序** 初始化的,与它们在初始化表中列出的顺序无关。  

!!! note "哪些情况必须用初始化列表"
    1.常量成员 const,不能对 const 做赋值，只能在初始化列表里写：```A() : x(10) {}```
    2.引用成员变量 int& r;```A(int& ref) : r(ref) {}```  
    3.成员对象（有自己构造函数的类成员）,必须在初始化列表里指定初始值，否则会产生两次构造（先默认构造，再赋值）。  

利用构造函数创建对象的两种方法:  
1.在栈上-利用构造函数直接创建对象.其一般形式为: ```类名  对象名[(实参表)];``` 这里的“类名”与构造函数名相同,“实参表”是为构造函数提供的实际参数。  
2.在堆上-利用构造函数创建对象时,通过指针和new来实现。其一般语法形式为:```类名 *指针变量 = new 类名[(实参表)];```，需要手动delete。例如： ```Date *date1=new Date(1998,4,28);```  
```cpp
//第二种的例子
void main()
{
	    Date *date1;
            date1=new Date(1998,4,28);     
                      //可合写成:Date *date1=new Date(1998,4,28);
	    cout<<"Date1 output1:"<<endl;
	    date1->showDate();          
	    date1->setDate(2002,11,14); 
	    cout<<"Date1 output2:"<<endl;
	    date1->showDate();          
	    delete date1;
}
```

缺省参数（默认参数）的构造函数  
```cpp
Coord(int a=0,int b=0){ x=a; y=b;}   // 带有缺省参数的构造函数

//或者写成初始化列表
Coord(int a=0, int b=0) : x(a), y(b) {}
```

构造函数的重载：  
1.构造函数重载：在一个类中可以定义多个构造函数，以便对类对象提供不同的初始化的方法，供用户选用。这些构造函数具有相同的名字，而参数的个数或参数的类型不相同（这称为构造函数的重载）  
2.建立对象时只执行其中一个构造函数，并非每个构造函数都被执行。  

```cpp
//定义多个构造参数：
class Student {
public:
    Student() {
        cout << "默认构造函数\n";
    }

    Student(string n) {
        cout << "一个参数构造函数\n";
    }

    Student(string n, int age) {
        cout << "两个参数构造函数\n";
    }
};
```

### 拷贝构造函数 
用于 用一个已经存在的对象 去 初始化另一个对象。  
通过等于号复制对象时，系统会自动调用拷贝构造函数。拷贝构造函数与原来的构造函数实现了函数的重载。  

拷贝构造函数的特点：  
1.因为该函数也是一种构造函数,所以其函数名与类名相同,并且该函数也没有返回值类型。  
2.该函数只有一个参数,并且是同类对象的引用。  
3.每个类都必须有一个拷贝构造函数。默认是一个缺省的拷贝构造函数。  

```cpp
//自定义拷贝构造函数
class 类名
{  public :
       类名（形参）；//构造函数
       类名（类名 &对象名）；//拷贝构造函数
           ...
}；
类名:: 类名（类名 &对象名）//拷贝构造函数的实现
{    函数体    }

//调用缺省的拷贝构造函数

```cpp
#include<iostream.h>
class Coord{
public:
    Coord(int a,int b)
    {  x=a; y=b; cout<<"Using normal constructor\n"; }
    void print(){ cout<<x<<"  "<<y<<endl;}
private:
    int x,y;  };
main()
{   Coord p1(30,40);    // 定义类Coord的对象p1,
                        // 调用了普通构造函数初始化对象p1
     Coord p2(p1);      // 以“代入”法调用缺省的拷贝构造函数,
                        // 用对象p1初始化对象p2
    Coord p3=p1;        // 以“赋值”法调用缺省的拷贝构造函数,
                        // 用对象p1初始化对象p3
    p1.print(); p2.print(); p3.print();
    return 0;
} 
```

调用拷贝函数的三种情况：  
1.当用类的一个对象去初始化该类的另一个对象时。  
2.当函数的形参是类的对象,调用函数,进行形参和实参结合时。  
```cpp
   fun1(Coord p)      // 函数的形参是类的对象
   { 
      p.print();
   }
   main()
  {
    Coord p1(10,20);
    fun1(p1);          // 当调用函数,进行形参和实参结合时,
                              调用拷贝构造函数
    return 0;
  }
```
3.当函数的返回值是对象,函数执行完成,返回调用者时。  
```cpp
Coord fun2()
{    Coord p1(10,30);
    return p1;    }    // 函数的返回值是对象

main()
{    Coord p2;
    P2=fun2(); // 函数执行完成,返回调用者时,调用拷贝构造函数                                  
    return 0;  }
```

**浅拷贝和深拷贝：**  
浅拷贝，就是由缺省的拷贝构造函数所实现的数据成员逐一赋值，若类中含有指针类型数据，则会产生错误。  
有指针必须用深拷贝
```cpp
class A {
    int *p;
public:
    A(int v) { p = new int(v); }

    // 拷贝构造函数 —— 深拷贝
    A(const A& other) {
        p = new int(*other.p);
    }

    ~A() { delete p; }
};
```

1.不管是浅拷贝还是深拷贝，传参都是传引用  
2.在深拷贝时，必须new一块新的堆内存  

### 析构函数
析构函数也是一种特殊的成员函数。它执行与构造函数相反的操作,通常用于撤消对象时的一些清理任务,如释放分配给对象的内存空间等。  

特点：  
1.析构函数与构造函数名字相同,但它前面必须加一个波浪号(~)  
2.析构函数没有参数,也没有返回值,而且不能重载。因此在一个类中只能有一个析构函数;  
3.当撤消对象时,编译系统会自动地调用析构函数。如果程序员没有定义析构函数，系统将自动生成和调用一个默认析构函数，默认析构函数只能释放对象的数据成员所占用的空间，但不包括堆内存空间  

析构函数被调用的两种情况：  
1.若一个对象被定义在一个函数体内，当这个函数结束时，析构函数被自动调用。   
2.若一个对象是使用new运算符动态创建，在使用delete释放时，自动调用析构函数。  

delete的使用：new了什么就delete什么，new[]了什么就delete[]什么  
`new T[n]` -> `delte[] T`  

### 构造函数和析构函数调用的顺序、对象的生存期
一般顺序：调用析构函数的次序正好与调用构造函数的次序相反：最先被调用的构造函数，其对应的（同一对象中的）析构函数最后被调用，而最后被调用的构造函数，其对应的析构函数最先被调用。  

* 局部对象是被定义在一个函数体或程序块内的，它的作用域限定在函数体或程序块内，生存期较短。
    * 局部自动对象(例如在函数中定义的对象)，则在建立对象时调用其构造函数。如果函数被多次调用，则在每次建立对象时都要调用构造函数。在函数调用结束、对象释放时先调用析构函数。
* 静态对象是被定义在一个文件中，它的作用域从定义是起到文件结束时为止。生存期较长。
    * 如果在函数中定义静态局部对象，则只在程序第一次调用此函数建立对象时调用构造函数一次，在调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束或调用exit函数结束程序时，才调用析构函数。
* 全局对象是被定义在某个文件中，它的作用域包含在该文件的整个程序中，生存期是最长的。
    * 在全局范围中定义的对象(即在所有函数之外定义的对象)，它的构造函数在所有函数(包括main函数)执行之前调用。在程序的流程离开其作用域时(如main函数结束或调用exit函数) 时，调用该全局对象的析构函数。
* 动态对象是由程序员掌握的，它的作用域和生存期是由new和delete之间的间隔决定的。

### 类的组合
类中的成员数据是另一个类的对象,可以在已有的抽象的基础上实现更复杂的抽象。  

```cpp
//eg:表示学生和地址的关系
#include <iostream>
#include <string>
using namespace std;

class Address {
public:
    string city;
    string street;

    Address(string c, string s) : city(c), street(s) {}
    void show() {
        cout << city << ", " << street << endl;
    }
};

class Student {
public:
    string name;
    int age;
    Address addr;  // 组合：Student“有一个”Address

    Student(string n, int a, Address ad) : name(n), age(a), addr(ad) {}
    void show() {
        cout << name << ", " << age << " years old, lives at ";
        addr.show();
    }
};

int main() {
    Address a1("Beijing", "Chaoyang Road");
    Student s1("Tom", 20, a1);
    s1.show();
}
//当 Student 对象被销毁时，它内部的 Address 对象也被销毁
```

类组合的构造函数调用：  
1.构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反）  
2.若调用默认构造函数（即无形参的），则内嵌对象的初始化也将调用相应的默认构造函数。  

前向引用声明：  

* 如果需要在某个类的声明之前，引用该类，则应进行前向引用声明。前向引用声明只为程序引入一个标识符，但具体声明在其它地方。  
* 使用前向引用声明虽然可以解决一些问题，但它并不是万能的。需要注意的是，尽管使用了前向引用声明，但是在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象。  
* 应该记住：当你使用前向引用声明时，你 **只能使用被声明的符号** ，而不能涉及类的任何细节。

```cpp
//eg
class B;  //前向引用声明
class A
{  public:
      void f(B b);
};
class B
{  public:
      void g(A a);
};
```

## 类的设计
### 自引用指针this ；
* 每一个类的成员函数都有一个隐藏定义的常量指针，我们把它称为this指针。this指针的类型就是成员函数所属的类的类型。 
* this指针是隐式使用的，它是作为参数被传递给成员函数的。
* 自动实现：是编译系统自动实现的，程序设计者不必人为地在形参中增加this指针，也不必将对象a的地址传给this指针。
* `*this`表示对象当前对象本身（比如说调用了Class类内有学生lihua，this的类型是`Class*`，this是指向lihua的指针，*this就是lihua本身）

```cpp
class Circle
{
private:
    double radius;
public:
    Circle(double radius)  // 参数与数据成员同名时
    {
         this->radius = radius;  // 去掉 this 如何理解？-实际上是 把参数赋值给自己，成员变量根本没被修改
         //this->radius 指的是 类的成员变量 radius
         //radius（右边）指的是 函数参数 radius
    }                                  
    double get_area()
    {
        return 3.14 * radius * radius;
    }
};
int main()
{
    Circle c = Circle(1);
    double a = c.get_area();
    cout << a << endl;
    return 0;
}
```

!!! note
    上面这个例子也可以使用初始化列表写
    ```Circle(double radius) : radius(radius) {}  // 左边是成员变量，右边是参数```
### 对象数组与对象指针；
对象数组：每一数组元素都是对象的数组，也就是说，若一个类有若干个对象，则把这一系列的对象用一个数组来存放。对象数组的元素是对象，不仅具有数据成员，而且还有函数成员。  
```类名 数组名[下标表达式]; ```  

与基本数据类型的数组一样,在使用对象数组时也只能访问单个数组元素,也就是一个对象,通过这个对象,也可以访问到它的公有成员,一般形式是:```数组名[下标].成员名```   

如果需要建立某个类的对象数组，在设计类的构造函数时就要充分考虑到数组元素初始化的需要；  
当各个元素的初值要求为相同的值时，应该在类中定义出不带参数的构造函数或带缺省参数值的构造函数；  
当各元素对象的初值要求为不同的值时需要定义带形参(无缺省值)的构造函数。
定义对象数组时，可通过初始化表进行赋值。  

```cpp
#include<iostream.h>
	class exam{
	public:
	    exam()
	     { x=123;}
	    exam(int n)
	     { x=n;}
	    int get_x()
	     { return x; }
	private:
    int x;  
	};
main()
	{  exam ob1[4]={11,22,33,44};   
	    exam ob2[4]={55,66};   
          exam ob3[4]={exam(11),exam(22),exam(33),exam(44)};  
	    exam ob4[4]={exam(55),exam(66)};  
	    ob4[2]=exam(77);
	    ob4[3]=exam(88);   
	    int i;
	    for (i=0;i<4;i++)
	        cout<<ob1[i].get_x()<<' ';
	    cout<<endl;
	    for (i=0;i<4;i++)
	        cout<<ob2[i].get_x()<<' ';
	    cout<<endl;
	    for (i=0;i<4;i++)
            cout<<ob3[i].get_x()<<' ';
          cout<<endl;
          for (i=0;i<4;i++)
             cout<<ob4[i].get_x()<<' ';
	    cout<<endl;  
         return 0;    
}
```
对象指针  
每一个对象在初始化后都会在内存中占有一定的空间。因此，即可以通过对象名访问一个对象，也可以通过对象地址来访问一个对象。对象指针就是用于存放对象地址的变量。声明对象指针的一般语法形式为:```类名* 对象指针名;```  

1.用指针访问单个对象成员  
```cpp
  #include<iostream.h>
class exe{
public:
    void set_a(int a){ x=a; }
    void show_a(){ cout<<x<<endl; }
private:
    int x;
};
main()
{  
    exe ob,*p;     // 声明类exe的对象ob和类exe的对象指针p
    ob.set_a(2);
    ob.show_a();       // 利用对象名访问对象的成员
    p=&ob;             // 将对象ob的地址赋给对象指针p
    p->show_a();       // 利用对象指针访问对象的成员
    return 0;	
} 
//结果
//2
//2
```
2.用对象指针访问对象数组 
将对象数组的首地址赋给对象指针
```cpp
main()
{  exe ob[2],*p;
  ob[0].set_a(10);
      ob[1].set_a(20);
      p=ob;
   p->show_a();
   p++;
   p->show_a();
   return 0;
}
//结果：10 20

```

**指向类的成员的指针**  
类的成员自身也是一些变量、函数或者对象等。因此，也可以直接将它们的地址存放到一个指针变量中，这样就可以使指针直接指向对象的成员，进而可以通过指针访问对象的成员。  

* 指向成员的指针只能访问公有数据成员和成员函数。
* 使用要先声明，再赋值，然后访问。

1.指向数据成员的指针  
```cpp
//声明：类型说明符 类名:: *数据成员指针名；
//赋值：数据成员指针名＝&类名:: 数据成员名
//使用：对象名. *数据成员指针名
//            对象指针名-> *数据成员指针名
#include<iostream.h>
class A{
public:
    A(int i)    {  z=i;  }
    int z;
};
void main(){ 
    A ob(5);
    A *pc1;        	// 声明一个对象指针pc1
    pc1=&ob;         	// 给对象指针pc1赋值
    int A∷*pc2;     // 声明一个数据成员指针pc2  // ①
    pc2=&A∷z;     // 给数据成员指针pc2赋值    // ②
    cout<<ob.*pc2<<endl;        // 用成员指针pc2访问数据成员z
    cout<<pc1->*pc2<<endl;    // 用成员指针pc2访问数据成员z 
    cout<<ob.z<<endl;     	      // 使用对象名访问数据成员z
}

```

2.指向成员函数的指针
```cpp
//声明：类型说明符  (类名∷ *指针名)(参数表); 
//赋值：成员函数指针名 = 类名∷成员函数名; 
//使用：(对象名.*成员函数指针名)(参数表)  ;
//     （对象指针名 -> *成员函数指针名）(参数表) ;
#include<iostream.h>
class Coord {
public:
      Coord(int a=0,int b=0)  { x=a; y=b; }
	 int getx()  { return x; }
	 int gety()  { return y; }
private:
    int x,y;  };
void main() 
{   Coord op(5,6);   
    Coord *pc1=&op; 
    int (Coord∷*pc_getx)();  
    pc_getx=Coord∷getx; 
    cout<<pc1->getx()<<endl; 
    cout<<op.getx()<<endl; 
    cout<<(op.*pc_getx)()<<endl;
    cout<<(pc1->*pc_getx)()<<endl;  
}

```

### 向函数传递对象；
使用对象作为函数参数：  
对象可以作为参数传递给函数，其方法与传递其他类型的数据相同。在向函数传递对象时，是通过传值调用传递给函数的。因此，函数中对对象的任何修改均不影响调用该函数的对象本身。  

```cpp
#include<iostream.h>
class aClass{
 public:
        aClass(int n) { i=n; }
        void set(int n){ i=n; }
        int get( ){ return i; }
private:
        int i; };
void sqr(aClass ob)
{ ob.set(ob.get()*ob.get());
   cout<<"copy of obj has i value of ";
   cout<<ob.get()<<"\n"; }
main()
{ aClass  obj(10);
   sqr(obj);  
   cout<<"But, obj.i is unchanged in main:";
   cout<<obj.get( );    return 0;  } 
```

使用对象指针作为函数参数：  
对象指针可以作为函数的参数，使用对象指针作为函数参数可以实现传址调用，即可在被调用函数中改变调用函数的参数对象的值，实现函数之间的信息传递。同时使用对象指针实参仅将对象的地址值传给形参，而不进行副本的拷贝，这样可以提高运行效率，减少时空开销。  
当函数的形参是对象指针时，调用函数的对应实参应该是某个对象的地址值。（取址就行，不需要再写一个指针，把指针传进去）  

```cpp
#include<iostream.h>
class aClass {
  public:
     aClass(int n) { i=n; }
     void set(int n){ i=n; }
      int get(){ return i;}
  private:
     int i; };
  void sqr(aClass  *ob)
    { ob->set(ob->get() * ob->get());
       cout<<"Copy of obj has i value of ";
       cout<<ob->get()<<"\n"; }
main()
 {  aClass obj(10);
    sqr(&obj);
   cout<<"Now, obj.i in main() has been changed :";
  cout<<obj.get() <<"\n";  return 0;  
} 
```

使用对象引用作为函数参数：  
使用对象引用作为函数参数不但具有用对象指针作函数参数的优点，而且用对象引用作函数参数将更简单、更直接。  
```cpp
//...
void sqr(aClass& ob)
{   ob.set(ob.get() * ob.get());
     cout<<"Copy of obj has i value of ";
     cout<<ob.get()<<"\n"; }
main()
 { aClass obj(10);
    sqr(obj);
    cout<<"Now, obj.i in main() has been changed :";
    cout<<obj.get() <<"\n";
    return 0;   } 
```


### 静态成员static
引入目的：实现一个类的不同对象之间数据和函数共享  
谁共享：本类所有对象  

静态数据成员 = 所有对象共享的变量  
静态成员函数 = 不需要对象就能调用的函数（只能访问静态数据成员）

* 静态数据成员
    * static关键字
    * 该类的所有对象维护该成员的同一个拷贝
    * 必须在类外定义和初始化，用`::`来指明所属的类
    * 初始化：```<数据类型><类名>∷<静态数据成员名>=<值>；```，初始化时不加该成员的访问权限控制符private，public等。初始化位置：定义对象之前，一般在类定义后，main()前进行。
    * 初始化时使用作用域来标明它所属的类，因此，静态数据成员是类的成员，而不是对象的成员
    * 引用静态数据成员：```<类名>::<静态成员名>```
    * 访问方式（只能访问公有静态数据成员）
        * 用类名访问```类名::静态数成员```
        * 用对象访问```对象名.静态数据成员``` 或 ```对象指针->静态数据成员```
    * 私有静态数据成员不能被类外部函数访问，也不能用对象进行访问。
```cpp
#include<iostream.h>
class myclass
{   public:
    static int i;
    int geti()
     { return i;}
};
int myclass∷i=0; // 初始化,不必在前面加static
main()
{ myclass∷i=200;
    myclass ob1,ob2;
    cout<<"ob1.i="<<ob1.geti()<<endl;
    cout<<"ob2.i="<<ob2.geti()<<endl;
    ob1.i=300;  // 对象进行访问
    cout<<"ob1.i="<<ob1.geti()<<endl;
    cout<<"ob2.i="<<ob2.geti()<<endl;
    return 0;
}
```
* 静态成员函数
    * 类外代码可以使用类名和作用域操作符来调用公有静态成员函数
    * 静态成员函数只能引用属于该类的静态数据成员或静态成员函数。静态成员函数中没有指针this，所以访问非静态数据成员，必须通过参数传递方式得到对象名，通过对象名访问。
    * 使用static关键字声明函数成员。同静态数据成员一样，静态成员函数也属整个类，由同一个类的所有对象共同维护，为这些对象所共享。
    * 定义静态成员函数```static 返回类型 静态成员函数名（参数表）```
    * 使用静态成员函数
        * ```类名::静态成员函数名(实参表)```
        * ```对象. 静态成员函数名(实参表)```
        * ```对象指针->静态成员函数名(实参表)```
    * 静态成员函数可以定义成内嵌的，也可以在类外定义，在类外定义时不能用static前缀。
    * 静态成员函数主要用来访问全局变量或同一个类中的静态数据成员。特别是，当它与静态数据成员一起使用时，达到了对同一个类中对象之间共享数据进行维护的目的。
    * 私有静态成员函数不能被类外部函数和对象访问。

```cpp
#include<iostream.h>
class small_cat {
    public:
    small_cat(double w)
    {   weight=w;
        total_weight+=w;        
        total_number++;  }
    static  void display(small_cat& w)//访问非静态成员	
    { cout<<"The small_cat weights  "<<w.weight<<" kg\n";}
    static void total_disp() //访问静态成员
    {   cout<<total_number<<" small_cat total_weight ";
        cout<<total_weight<<"kg "<<endl;    }
    private:
    double weight;               	
    static double total_weight;   
    static double total_number;  
};
double small_cat∷total_weight=0;	
double small_cat∷total_number=0;

int main()
{   small_cat w1(0.9)，w2(0.8)，w3(0.7);
    small_cat∷display(w1);
    small_cat∷display(w2); 
    small_cat∷display(w3); 
    small_cat∷total_disp(); 
    return 0;
} 

```

通过普通指针访问静态成员：  
就指针该咋用就咋用  

通过指针访问类的静态成员函数
```cpp
//通过指针访问类的静态成员函数
#include<iostream.h>
class myclass {
public:
    myclass()       
      {   ++i;  }
    static int geti()  	
      {   return i;  }//静态成员函数
private:
    static int i;     
};
int myclass::i=0;     	
main()
{  int (*get)()=myclass::geti;  //指针访问静态成员函数
   myclass ob1,ob2,ob3;
   cout<<"myclass∷i="<<(*get)()<<endl; 	//使用指针
   return 0;
}
```

* 静态成员函数可以定义成内嵌的，也可以在类外定义，在类外定义时不能用static前缀。
* 静态成员函数主要用来访问全局变量或同一个类中的静态数据成员。特别是，当它与静态数据成员一起使用时，达到了对同一个类中对象之间共享数据进行维护的目的。
* 私有静态成员函数不能被类外部函数和对象访问。
* 使用静态成员函数的一个原因是，可以用它在建立任何对象之前处理静态数据成员。这是普通成员函数不能实现的。
* 静态成员函数中没有指针this，所以静态成员函数不访问类中的非静态数据成员，若确实需要则只能通过对象名（作为参数）访问

静态成员函数访问非静态数据成员  

```cpp
#include<iostream.h>
class small_cat {
  public:
    small_cat(double w)
    { weight=w;
      total_weight+=w;        
      total_number++;  }
  static  void display(small_cat& w)//访问非静态成员	
       { cout<<"The small_cat weights  "<<w.weight<<" kg\n";}
    static void total_disp() //访问静态成员
       { cout<<total_number<<" small_cat total_weight ";
             cout<<total_weight<<"kg "<<endl;    }
  private:
    double weight;               	
    static double total_weight;   
    static double total_number;  
};
double small_cat∷total_weight=0;	
double small_cat∷total_number=0;	

int main()
{   small_cat w1(0.9)，w2(0.8)，w3(0.7);
    small_cat∷display(w1);
    small_cat∷display(w2); 
    small_cat∷display(w3); 
    small_cat∷total_disp(); 
    return 0;
} 

```

### 友元；
友元可以访问与其有好友关系的类中的私有成员。友元包括友元函数和友元类。  
友元既可以是不属于任何类的一般函数,也可以是另一个类的成员函数,还可以是整个的类。友元函数不是当前类的成员函数，而是独立于当前类的外部函数，但它可以访问该类的所有对象的成员，包括私有、保护和公有成员  
友元函数没有this指针  

<!-- 友元函数的声明：  
位置：当前类体中  
格式：函数名前加```friend```  

友元函数的定义：  
类体外：同一般函数（函数名前不能加 `类名::`）  
类体内：函数名前加`friend`   -->

友元函数的声明和定义  

* 普通友元函数
    * 在类中声明，函数名前加```friend```
    * 在类外定义，同一般函数（函数名前不能加 `类名::`）
* 类 B 的成员函数作为类 A 的友元（授予权限的是A，获得权限的事B）
    * 类 A 声明友元，函数名前加```friend```，加上```B类名::```
    * 类 B 定义成员函数，什么都不加（形参是A类对象的引用）  
    * 类外定义，函数名前加上```B类名::```

友元函数一般带有一个该类的入口参数。因为友元函数不是类的成员函数，它没有this指针，所以它不能直接引用对象成员的名字，也不能通过this指针引用对象的成员，它必须通过作为入口参数传递进来的对象名或对象指针来引用该对象的成员。  

```cpp
// friend functions 
#include <iostream> 
using namespace std; 
class Rectangle { 
	int width, height; 
public: 
	Rectangle() {} 
	Rectangle (int x, int y) : width(x), height(y) {}
 	int area() {return width * height;} 
	friend Rectangle duplicate (const Rectangle&); 
};
Rectangle duplicate (const Rectangle& param) { 
	Rectangle res; 
	res.width = param.width*2; 
	res.height = param.height*2; 
return res; 
} 
int main () { 
	Rectangle foo; 
	Rectangle bar (2,3); 
	foo = duplicate (bar); 
	cout << foo.area() << '\n'; 
	return 0; 
}
```

!!! note "函数声明"
    cpp中的函数声明可以只写参数类型，不写参数名，如```int f(int, float);```

友元函数可以是多个类的    
（注意前向引用）  

友元成员函数不仅可以是一般函数(非成员函数)，而且可以是另一个类中的成员函数  

!!! note "friend"
    友元关系一定写在“授予权限的那个类”里面。哪个类要把自己的`private`交给某个函数访问，就在那个类里写`friend`。  

```cpp
 #include<iostream.h>
#include<string.h>
class girl; //前向引用
class boy {
public:
    boy(char *n,int d)
    {   name=new char[strlen(n)+1];
        strcpy(name,n); age=d; }
    void disp(girl &);         // 声明disp()为类boy的成员函数
    ~boy(){ delete name;  }
private:
    char *name;
    int age;
};
class girl {
public:
    girl(char *n,int d){
        name=new char[strlen(n)+1];
        strcpy(name,n); age=d; }
    friend void boy::disp(girl &); 
    ~girl(){ delete name; }
private:
	char *name;
    int age; };
	void boy::disp(girl &x)
	{   cout<<"Boy\′s name is "<<name<<",age:"<<age<<"\n";
	    cout<<"Girl\′s name is "<<x.name<<",age:"<<x.age<<"\n";}
    void main()
    {   boy b("Chen Hao",25);
        girl e("Zhang Wei ",18);
        b.disp(e);
    }

// 程序运行结果如下:
// Boy′s name is Chen Hao ,age: 25
// Girl′s name is: Zhang Wei ,age: 18 
```

友元类  
不仅可以将一个函数声明为一个类的“朋友”，而且可以将一个类(例如B类)声明为另一个类(例如A类)的“朋友”。这时B类就是A类的友元类。友元类B中的所有函数都是A类的友元函数，可以访问A类中的所有成员。  

```cpp
class  Y {
    //…
};
class X {
     //…
    friend  Y; // 声明类Y为类X的友元类
     //类Y的所有成员函数都是类X的友元函数
     //Y可以访问X的成员

}; 
```

* 友元的关系是单向的而不是双向的。  
* 友元的关系不能传递

!!! note "friend的位置"
    在 C++ 里，友元（friend）声明的位置对功能没影响，也就是：可以写在 private 区域,也可以写在 public 区域  
    friend 本质是 访问权限的授予，不是成员函数或成员变量  


### 对象成员；
如果一个类的对象是另一个类的数据成员,则称这样的数据成员为对象成员。  
```cpp
class A
{
    //'''
};
class B
{
    A a;//类A的对象a为类B的对象成员
    public:
    //...
}
```
### 常类型；
* 常数据成员
    * 用 const 声明的常数据成员，其值是不能改变的。只能通过构造函数的参数初始化表对常数据成员进行初始化。
    * 如果已定义了一个常对象，则只能调用其中的const成员函数，而不能调用非const成员函数(不论这些函数是否会修改对象中的数据)。如果需要访问对象中的数据成员，可将常对象中所有成员函数都声明为const成员函数，但应确保在函数中不修改对象中的数据成员。
* 常成员函数
    * 成员函数声明中包含const时为常成员函数。此时，该函数只能引用本类中的数据成员，而不能修改它们（注意：可以改mutable成员），即成员数据不能作为语句的左值。
    * ```void show_Time( ) const;```
* 指向常对象的指针变量
    * ```const 类型 *指针变量名```
    * 指向常对象（变量）的指针变量，不能通过它来改变所指向目标对象的值，但指针变量的值是可以改变的。
    * 如果被声明为常对象（变量），只能用指向常对象（变量）的指针变量指向它，而不能非const型指针变量去指向它。
    * 指向常对象（变量）的指针变量除了可以指向常对象（变量）外，还可以指向未被声明为const的对象（变量）。此时不能通过此指针变量改变该变量的值。
    * 指向常对象（变量）的指针变量可以指向const和非const型的对象（变量），而指向非const型变量的指针变量只能指向非const的对象（变量）。
    * 如果函数的形参是指向非const型变量的指针，实参只能用指向非const变量的指针，而不能用指向const变量的指针，这样，在执行函数的过程中可以改变形参指针变量所指向的变量(也就是实参指针所指向的变量)的值
    * 如果函数形参是指向const型变量的指针，允许实参是指向const变量的指针，或指向非const变量的指针。
    * 希望在调用函数时对象的值不被修改，就应当把形参定义为指向常对象的指针变量，同时用对象的地址作实参(对象可以是const或非const型)。如果要求该对象不仅在调用函数过程中不被改变，而且要求它在程序执行过程中都不改变，则应把它定义为const型
* 对象的常引用
    * 经常用常指针和常引用作函数参数



### 多文件组成；

## 继承与派生类
### 继承与派生类
基类（Base class）/父类（Parent class）：被继承的类  
派生类（Derived class）/子类（Child class）：继承基类的类  

继承内容：除构造函数、析构函数、私有成员外的其他成员  
保持已有类的特性而构造新类的过程称为 **继承** 。  
在已有类的基础上新增自己的特性而产生新类的过程称为 **派生** 。  

从已有类派生出新类时,可以在派生类内完成以下几种功能:  

* 可以增加新的数据成员;
* 可以增加新的成员函数;
* 可以重新定义基类中已有的成员函数;、
* 可以改变现有成员的属性。

!!! note "name hiding"
    mark一下。

继承方式和访问权限  

|继承方式|基类 public → 派生类访问|基类 protected → 派生类访问|基类 private → 派生类访问|外部通过派生类对象访问基类成员|
|------|---------|--------|-------|-------|
|public|public|protected|×（hidden）|public 成员可访问，protected ×|
|protected|protected|protected|×（hidden）|外部不可访问|
|private|private|private|×（hidden）|外部不可访问|

声明一个派生类的一般方式

```cpp

class  派生类名:继承方式  基类名 
{
       //派生类新增的数据成员和成员函数
    }; 
```

默认为private私有继承  

什么时候使用`protected`？  
public to all derived classes  
`private`只对自己和友元可见  

保护成员对于派生类的成员函数而言是公有成员，而对于其他函数就仍是私有成员  

基类与派生类的关系：  
狗和黑狗白狗uika的关系

### 派生类的构造函数和析构函数
* 基类的构造函数和析构函数不能被继承，一般派生类要加入自己的构造函数  
* 派生类构造函数和析构函数的执行顺序
    * 通常情况下,当创建派生类对象时,首先执行基类的构造函数,随后再执行派生类的构造函数;
    * 当撤消派生类对象时,则先执行派生类的析构函数,随后再执行基类的析构函数。 
* 当基类的构造函数没有参数，或没有显式定义构造函数时，派生类可以不向基类传递参数，甚至可以不定义构造函数；当基类含有带参数的构造函数时，派生类必须定义构造函数，以提供把参数传递给基类构造函数的途径。

```cpp
//派生类构造函数的一般格式
派生类名(参数总表):基类名(参数表)
{
 // 派生类新增成员的初始化语句
}
//   基类构造函数的参数，通常来源于派生类构造函数参数总表，也可以用常量值

#include<iostream.h>	
class Base {
public:	
    Base(int n)                      //基类的构造函数
    {
    cout<<"Constructing base class\n";
    i=n;
    }
    ~Base()                          //基类的析构函数
    {  
    cout<<"Destructing base class\n";  
    }
    void showi()
    {   
        cout<<i<<endl;  
    }
private:	
    int i;	
}; 

class Derive :public Base{ 
public:
    Derive(int n,int m):Base(m) // 定义派生类构造函数时,缀上基类的构造函数
    {	 
    cout<<"Constructing derived class"<<endl; 
    j=n;              
    }
    ~Derive()                                //派生类的析构函数
    {  
    cout<<"Destructing derived class"<<endl;	 
    }
    void showj()     
    { 
    cout<<j<<endl;
    }
private:
    int j;
};
main()
{   
    Derive obj(50,60);
    obj.showi(); 
    obj.showj();
    return 0;       
}
```

当派生类中含有内嵌对象成员时,其构造函数的一般形式为: (当派生类既继承了一个基类，又“内嵌”（组合）了其他对象成员时，构造函数的写法规则。) 
```cpp
派生类名(参数总表):基类名(参数表1),内嵌对象名1(内嵌对象参数表1),…,内嵌对象名n(内嵌对象参数表n)
{
     // 派生类新增成员的初始化语句
    } 
//	✅ 继承了一个基类
//  ✅ 又包含了额外的“对象成员”（组合）
```
撤消对象时,析构函数的调用顺序与构造函数的调用顺序正好相反。  

* 当基类构造函数不带参数时，派生类可不定义构造函数，但基类构造函数带有参数，则派生类必须定义构造函数。
* 若基类使用缺省构造函数或不带参数的构造函数，则在派生类中定义构造函数时可略去“：基类构造函数名（参数表）”
* 如果派生类的基类也是一个派生类，每个派生类只需负责其直接基类的构造，依次上溯。
* 由于析构函数是不带参数的，在派生类中是否定义析构函数与它所属的基类无关，基类的析构函数不会因为派生类没有析构函数而得不到执行，基类和派生类的析构函数是各自独立的。

### 多继承
* 单继承
    * 派生类只从一个基类派生。
* 多继承
    * 派生类从多个基类派生。
* 多重派生
    * 由一个基类派生出多个不同的派生类。
* 多层派生
    * 派生类又作为基类，继续派生新的类。

有两个以上基类的派生类声明的一般形式如下:
```cpp
//
class 派生类名:继承方式1  基类名1,…,继承方式n  基类名n{
      // 派生类新增的数据成员和成员函数
}; 
```

对基类成员的访问必须是无二义性  
使用类名限定可以消除二义性，例如：  
```obj.X∷f();``` 调用类X的f()  
```obj.Y∷f();``` 调用类Y的f()  

多继承构造函数定义的一般形式如下:  
```cpp
派生类名(参数总表):基类名1(参数表1),基类名2(参数表2),…,基类名n(参数表n)
{
    // 派生类新增成员的初始化语句
}
```

* 构造函数的执行顺序同单继承：
    * 先执行基类构造函数，再执行对象成员的构造函数，最后执行派生类构造函数。
    * 必须同时负责该派生类所有基类构造函数的调用。派生类的参数个数必须包含完成所有基类初始化所需的参数个数。
    * 处于同一层次各基类构造函数执行顺序，取决于 **声明派生类时所指定各基类的顺序** ，与派生类构造函数中所定义的成员初始化列表的各项顺序无关。

### 虚基类
* 当某一个类的多个直接基类是从另一个共同基类派生而来时，这些直接基类中从上一级基类继承来的成员就拥有相同的名称。在派生类的对象中，这些同名成员在内存中同时拥有多个拷贝。如何进行分辨呢？
    * 一种方法就是使用作用域标示符来唯一表示它们。
    * 另一种方法是定义虚基类，使派生类中只保留一份拷贝

虚继承（virtual 继承）用于解决多重继承中“菱形继承（diamond）”导致的基类重复拷贝问题：把共同的基类作为 共享的单一基类子对象，而不是让每个中间派生类各自拷贝一份  

```cpp
//非虚基类例子
#include <iostream.h>   
class base {
    public:
        base(){ a=5; cout<<"base a="<<a<<endl;  }  
    protected:
        int a;
};
class  base1:public base{
    public:
        base1()
        { a=a+10; cout<<"base1 a="<<a<<endl; } 
};
class base2:public base{
     public:
        base2(){a=a+20; cout<<"base2 a="<<a<<endl;} 
}; 

class derived:public base1,public base2{
    public:
        derived()
        {   cout<<"base1::a="<<base1::a<<endl;
            cout<<"base2::a="<<base2::a<<endl;
        } 
};
main()
{      derived  obj;
        return  0; 
}
//程序运行结果如下：
// base a=5
// base1 a=15
// base a=5
// base2 a=25
// base1::a=15
// base2::a=25
```

虚基类的声明:  
```cpp
//位置：定义派生类时声明
class  派生类名:virtual  继承方式  类名{
    //…
   } 
```

虚基类的例子:  
```cpp
#include <iostream.h>   
class base {
    public:
        base( ){ a=5; cout<<"base a="<<a<<endl;}  
protected:
         int a;
};
class base1: virtual public base{//虚基类声明
    public:
        base1( ){ a=a+10; cout<<"base1 a="<<a<<endl;} 
};
class base2: virtual public base{//虚基类声明
    public:
        base2( ){ a=a+20; cout<<"base2 a="<<a<<endl;} 
}; 

class derived:public base1,public base2{
    public:
        derived( ){ cout<<"derived a="<<a<<endl;} 
};
main( )
{  derived  obj; return  0; 
}
// 程序运行结果如下：:
// base a=5
// base1 a=15
// base2 a=35
// derived a=35 

```

* 如果在虚基类中定义有带形参的构造函数,并且没有定义缺省形参的构造函数,则整个继承结构中,所有直接或间接的派生类都必须在构造函数的成员初始化表中列出对虚基类构造函数的调用,以初始化在虚基类中定义的数据成员。
* 建立一个对象时,如果这个对象中含有从虚基类继承来的成员,则虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。该派生类的其他基类对虚基类构造函数的调用都自动被忽略。
* 由于继承结构的层次可能很深，规定将在建立对象时所指定的类称为最（远）派生类。
* 若同一层次中同时包含虚基类和非虚基类,应先调用虚基类的构造函数,再调用非虚基类的构造函数,最后调用派生类构造函数;
* 对于多个虚基类,构造函数的执行顺序仍然是先左后右,自上而下;
* 对于非虚基类,构造函数的执行顺序仍是先左后右,自上而下;
* 若虚基类由非虚基类派生而来,则仍然先调用基类构造函数,再调用派生类的构造函数。
* 关键字virtual与继承方式关键字(public或private)的先后顺序无关紧要，它只说明是“虚拟继承”。下面二个虚继承方法是等价
* 一个基类在作为某些派生类虚基类的同时，又作为另一些派生类的非虚基类，这种情况是允许的。
### 赋值兼容规则
* 所谓赋值兼容规则是指在需要基类对象的任何地方都可以使用公有派生类的对象来替代。这样,公有派生类实际上就具备了基类的所有特性,凡基类能解决的问题,公有派生类也能解决。
    * 派生类的对象可以被赋值给基类对象。
    * 派生类的对象可以初始化基类的引用。
    * 指向基类的指针也可以指向派生类。
    * 通过基类对象名、指针只能使用从基类继承的成员
* 声明为指向基类对象的指针可以指向它的公有派生的对象，但不允许指向它的私有派生的对象。
*  允许将一个声明为指向基类的指针指向其公有派生类的对象，但是不能将一个声明为指向派生类对象的指针指向其基类的一个对象

### conversion类型转换upcasting
可以创建一个父类的指针或引用，让他指向一个子类的对象。通过指针指向的对象（子类对象）会被当成父类的对象去使用。  

upcasting是多态的前提  

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void eat() { cout << "Animal eats\n"; }
};

class Dog : public Animal {
public:
    void bark() { cout << "Dog barks\n"; }
};

int main() {
    Dog d;              // 子类对象
    Animal* pa = &d;    // 父类指针指向子类对象（upcasting）
    
    pa->eat();           // ✅ 可以调用父类成员
    // pa->bark();       // ❌ 父类指针不能调用子类特有成员
}

//输出:Animal eats
```
1.派生的对象可以赋给基类的对象。
如：(约定derived是从类base公有派生而来的)  
```cpp
derived d;
base b;
b=d;
```

2.派生类的对象可以初始化基类的引用。如：  
```cpp
derive d; 
base &br=d;
```

3.派生类对象的地址可以赋给指向基类的指针，如：  
```cpp
derived d;
base *pb=&d;
```

在后两种情况下，通过指针或引用只能访问对象d中所继承的基类成员。

## 多态性与虚函数

### 多态性polymorphism
所谓 **多态性** 就是不同对象收到相同的消息时，产生不同的动作  

* 多态性的两种描述：
    * 指具有不同功能的函数可以用同一个函数名；
    * 指向不同的对象发送同一个消息，不同的对象在接收时会产生不同的行为；
* 从实现角度看，分为静态多态性和动态多态性
    * 静态多态性——函数重载和运算符重载；
    * 运行时的多态——继承和虚函数；
* 多态的实现：
    * 函数重载；
    * 运算符重载；
    * 虚函数；
* 静态绑定
    * 代码怎么写就绑定什么
* 动态绑定
    * 父类和子类有继承关系、出现虚函数

多态的分类：  

* 通用多态
    * 参数多态：与类属函数和类属类相关联，函数模板和类模板就是这种多态
    * 包含多态：是研究类族中定义于不同类中的同名成员函数的多态行为，主要是通过虚函数来实现的
* 专用多态
    * 重载多态：如函数重载、运算符重载等。普通函数及类的成员函数的重载多属于重载多态
    * 强制多态：是指将一个变元的类型加以变化，以符合一个函数或操作的要求，例如加法运算符在进行浮点数与整型数相加时，首先进行类型强制转换，把整型数变为浮点数再相加的情况，就是强制多态的实例。

### 联编
多态的实现和联编这一概念有关，所谓联编就是把函数名与函数体的程序代码连接(联系)在一起的过程。  
静态联编就是在编译阶段完成的联编。  
动态联编是运行阶段完成的联编。  

* 编译时的多态：编译时的多态是通过静态联编来实现的。
    * 静态联编时，系统用实参和形参进行匹配，对于同名的重载函数便根据参数上的差异进行区分，然后进行联编。从而实现了多态性。
* 运行时的多态：运行时的多态是用动态联编实现的。
    * 当程序调用到某一函数名时，才去寻找和连接其程序代码，对面向对象的程序设计而言，就是当对象接收到某一消息时，才去寻找和连接相应的方法。
* 在C++中，编译时多态性主要是通过函数重载和运算符重载实现的。运行时多态性主要是通过虚函数来实现的。

### 虚函数
虚函数允许函数调用与函数体之间的联系在运行时才建立，也就是在运行时才决定如何动作，即所谓的动态联编。（动态绑定）  

虚函数是动态联编的基础。虚函数是成员函数，而且是非static的成员函数。说明虚函数的方法如下  
```virtual<类型说明符><函数名>(<参数表>)```  
其中，被关键字virtual说明的函数称为虚函数。  

!!! note "写法"
    推荐在父类前面标virtual，在子类加override

如果某类中的一个成员函数被说明为虚函数，这就意味着该成员函数在派生类中可能有不同的实现。当使用这个成员函数操作指针或引用所标识对象时，对该成员函数调用采取动态联编方式，即在运行时进行关联或束定  
动态联编只能通过指针或引用标识对象来操作虚函数。如果采用一般类型的标识对象来操作虚函数，则将采用静态联编方式调用虚函数。  

* 动态联编实现的条件
    * 要有说明的虚函数
    * 调用线束操作的是指向对象的指针或者对象引用，或者是由成员函数调用虚函数
    * 子类型关系的建立
* 虚函数的作用
    * 虚函数首先是基类中的成员函数,在其前面加上virtual关键字，并在派生类中被重载。

虚函数的定义
```cpp
virtual 函数类型 函数名(形参表)
{
    //  函数体
} 
```
派生类中重新定义时，其函数原型，包括返回类型、函数名、参数个数、参数类型的顺序，都 **必须与其基类中的原型完全相同**  

* 如果在派生类中，没有用virtual显示地给出虚函数声明，这时系统就会遵循以下的规则来判断一个成员函数是不是虚函数:
    * 该函数与基类的虚函数有相同的名称。
    * 该函数与基类的虚函数有相同的参数个数及相同的对应参数类型。
    * 该函数与基类的虚函数有相同的返回类型或者满足赋值兼容规则的指针、引用型的返回类型。

* 通过定义虚函数来使用C++提供的多态机制时，派生类应该从它的基类公有派生。赋值兼容规则成立的前提条件是派生类从其基类公有派生。
* 必须首先在基类中定义虚函数。在实际应用中，应该在类等级内需要具有动态多态性的几个层次中的最高层类内首先声明虚函数。
* 在派生类对基类中声明的虚函数进行重新定义时，关键字virtual可以写也可以不写。【最好写override】
* 使用对象名和点运算符的方式也可以调用虚函数，但是这种调用在编译时进行的是静态联编，它没有充分利用虚函数的特性。只有通过基类指针访问虚函数时才能获得运行时的多态性。
* 虚函数必须是其所在类的成员函数，而不能是友元函数，也不能是静态成员函数，因为虚函数调用要靠特定的对象来决定该激活哪个函数。但是虚函数可以在另一个类中被声明为友元函数。
* 内联函数不能是虚函数，因为内联函数是不能在运行中动态确定其位置的。即使虚函数在类的内部定义，编译时仍将其看作是非内联的。【内联函数：在函数内定义，或者用```inline```声明】
* 构造函数不能是虚函数。因为虚函数作为运行过程中多态的基础，主要是针对对象的，而构造函数是在对象产生之前运行的，因此虚构造函数是没有意义的。
* 析构函数可以是虚函数，而且通常说明为虚函数。
* 虚函数必须是非静态成员函数。这是因为静态成员函数不受 限于某个对象。

* 虚函数和普通函数重载的区别
    * 普通的函数重载时，其函数的参数个数或参数类型必须有所不同，函数的返回类型也可以不同。 
    * 当重载一个虚函数时，也就是说在派生类中重新定义虚函数时，要求函数名、返回类型、参数个数、参数的类型和顺序与基类中的虚函数原型完全相同。
```cpp
//用对象名调用（静态绑定❌ 无多态）
Dog d;
Animal a = d;
a.speak();   // 调用 Animal::speak（编译期就定好了）

//用基类指针调用（动态绑定 ✅ 多态生效）
Animal* p = new Dog();
p->speak();   // 调用 Dog::speak（运行时才决定）

//基类引用调用（✅ Dog d;
Animal& r = d;
r.speak();    // 调用 Dog::speak
```

### 虚构函数
在程序用带指针参数的delete运算符撤销对象时，会发生一个情况: 系统会只执行基类的析构函数，而不执行派生类的析构函数。  

* 将基类的析构函数声明为虚函数。
* 析构函数设置为虚函数后，在使用指针引用时可以动态联编，实现运行时的多态，保证使用基类类型的指针能够调用适当的析构函数针对不同的对象进行清理工作。
* 如果一个类的析构函数是虚函数，那么，由它派生而来的所有派生类的析构函数也是虚析构函数，不管它是否使用了关键字virtual进行说明。
* 虚析构函数的定义格式：```Virtual ~类名（）；```

### 纯虚函数&抽象类
纯虚函数是一个在基类中说明的虚函数，它在该基类中没有定义，但要求在它的派生类中必须定义自己的版本，或重新说明为纯虚函数  

定义：```virtual  <函数类型>  <函数名> ( 参数表 ) = 0;```  
纯虚函数与一般虚函数成员的原型在书写形式上的不同就在于后面加了“=0”，表明在基类中不用定义该函数，它的实现部分（函数体）留给派生类去做。

* 纯虚函数没有函数体；
* 最后面的“=0”并不表示函数返回值为0; 
* 这是一个声明语句，最后应有分号。
* 纯虚函数只有函数的名字而不具备函数的功能，不能被调用。在派生类中对此函数提供定义后，它才能具备函数的功能，可被调用。
* 如果在一个类中声明了纯虚函数，而在其派生类中没有对该函数定义，则该虚函数在派生类中仍然为纯虚函数。


一个具有纯虚函数的类称为**抽象类。**  

* 由于抽象类中至少包含一个没有定义功能的纯虚函数。因此，抽象类只能作为其他类的基类来使用， **不能建立抽象类的对象** ，纯虚函数的实现由派生类给出
* 不允许从具体类派生出抽象类
* 抽象类不能用作参数类型、函数返回类型或显式转换的类型。
* 可以声明指向抽象类的指针或引用，此指针可以指向它的派生类，进而实现多态性。
* 抽象类的析构函数可以被声明为纯虚函数，这时，应该至少提供该析构函数的一个实现。
* 在抽象类中也可以定义普通成员函数或虚函数，虽然不能为抽象类声明对象，但仍然可以通过派生类对象来调用这些不是纯虚函数的函数。


```cpp
//一个实现:
// ✅ 你不仅要在类里声明
// ✅ 还要在类外真正写出函数体 { ... }
class Base {
public:
    virtual ~Base() = 0;   // 声明为纯虚
};

// 在类外提供实现
Base::~Base() {
    cout << "Base destructor\n";
}
```

```cpp
class  Shape {
public：
    virtual  void  rotateshape(int)=0;
    virtual  void  drawshape()=0;
    virtual  void  hiliteshape()=0;
    //…
};
Shape s1;         	//错误,不能建立抽象类的对象
Shape* ptr;       	//正确,可以声明指向抽象类的指针
Shape f();        	//错误,抽象类不能作为函数的返回类型
Shape g(shape s);	//错误,抽象类不能作为函数的参数类型
Shape& h(shape&); 	//正确,可以声明抽象类的引用

// abstract base class 

#include <iostream> 
using namespace std;
 
class Polygon { 
protected: 
	int width, height; 
public: 
	void set_values (int a, int b) { width=a; height=b; } 
	virtual int area (void) =0; 
}; 

class Rectangle: public Polygon { 
public: 
	int area (void) { return (width * height); }

};

class Triangle: public Polygon { 
public: 
	int area (void) { return (width * height / 2); } 
}; 

int main () { 
	Rectangle rect; 
	Triangle trgl; 
	Polygon * ppoly1 = &rect; 
	Polygon * ppoly2 = &trgl; 
	ppoly1->set_values (4,5); 
	ppoly2->set_values (4,5); 
	cout << ppoly1->area() << '\n'; 
	cout << ppoly2->area() << '\n'; 
	return 0; 
}

```

## 运算符重载
### 成员函数/友元函数运算符重载
* 运算符重载是实质上将运算对象转化为运算函数的实参，并根据实参的类型来确定重载的运算函数。
* 运算符重载和类型重载是多态的另外两种表现形式
* 运算符重载的方法是定义一个重载运算符的函数，在需要执行被重载的运算符时，系统就自动调用该函数，以实现相应的运算。也就是说，运算符重载是通过定义函数实现的。运算符重载实质上是函数的重载。

 重载运算符的函数一般格式如下：   
```cpp
函数类型 operator 运算符名称 (形参表列)
{ 对运算符的重载处理 }
```

* 运算符重载的规则
    * 只能重载C++中已有的运算符，不能臆造新的运算符；
    * 类属关系运算符`.`、作用域分辨符`::`、成员指针运算符`*`、`sizeof`运算符和三目运算符`？：`不能重载。
    * 重载之后运算符的优先级和结合性都不能改变；单目运算符只能重载为单目运算符，双目运算符只能重载为双目运算符；重载运算符的函数不能有默认的参数；
    * 运算符重载后的功能应当与原有功能相类似。必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象(或类对象的引用)。
    * 重载运算符含义必须清楚，不能有二义性。用于类对象的运算符一般必须重载，但运算符“=”和“&”不必用户重载。
* 运算符的重载形式
    * 重载为类的成员函数;
        * 就是在类中用关键字operator定义一个成员函数，函数名就是重载的运算符。运算符如果重载为类的成员函数，它就可以自由地访问该类的数据成员。
    * 重载为类的友元函数。

```cpp
//运算符重载为类的成员函数的一般格式为：
<类型> <类名>:: operator <要重载的运算符>（形参表）
{
    //函数体
}

//运算符重载为类的友元函数的一般语法形式为：
//二元运算符
friend  <函数类型>  operator  <运算符>(形参表)//类名 对象
{
    //函数体；
}
//类型及运算完成后返回的结果的类型

//一元运算符
<函数返回类型> operator<一元运算符> (类名 &对象)
{
	函数体
}


```

运算符重载为类的成员函数：   

双目运算：oprd1 B oprd2：  
把B重载为oprd1所属类的成员函数，只有一个形参，形参的类型是oprd2所属类。例如，经过重载之后，表达式oprd1 + oprd2就相当于函数调用```oprd1.operator +(oprd2)```   

单目运算  
1.前置单目运算：U oprd  
把U重载为oprd所属类的成员函数，没有形参。例如，“++”重载的语法形式为：```<函数类型>  operator  ++( );```,```++ oprd```就相当于函数调用```oprd.operator  ++( );```  
2.后置单目运算 oprd V  
运算符V重载为oprd所属类的成员函数，带有一个整型(int)形参。例如，后置单目运算符“- -”重载的语法形式为：```<函数类型>  operator - - ( int );```,```oprd-- 就相当于函数调用oprd.operator - - ( 0 );```  

```cpp
//前置 ++：返回 加完后的对象本身（引用）
//后置 ++：返回 加之前的旧值（值，不是引用）
class Time
{
	public:
         Time(int h=0,int m=0,int s=0);
        //其他构造函数省略
         void Show();//显示时：分：秒的成员函数
         friend Time& operator++(Time &t); 
         //定义前置＋＋运算符重载成员函数
         friend Time operator++(Time &t,int);
         //定义后置＋＋运算符重载成员函数
         //这个 int 只是为了区分前/后置
	private:
         int hour,minute,second;
};
```
前置的实质：  
```cpp
t++;
return t;      // 没有拷贝
```

后置的实质：  
```cpp
Time old = t;   // 多一次拷贝
t++;
return old;
```

运算符重载为友元函数：  
双目运算：oprd1 B oprd2  
双目运算符B重载为oprd1所属类的友元函数，该函数有两个形参，表达式`oprd1 B oprd2`就相当于函数调用`operator B (oprd1，oprd2)`。  

单目运算：  
1.前置单目运算：U oprd   
前置单目运算符U重载为oprd所属类的友元函数，表达式U oprd相当于函数调用`operator U(oprd)`。  
2.后置单目运算oprd V  
后置单目运算符V重载为oprd所属类的友元函数，表达式oprd V相当于函数调用`operator V(oprd，int)`。  

其中，函数返回类型为运算符重载函数的返回类型。operator<重载运算符>为重载函数名。当重载函数作为友元普通函数时，重载函数不能用对象调用，所以参加运算的对象必须以形参方式传送到重载函数体内，在二元运算符重载函数为友元函数时，形参通常为二个参加运算的对象。  


``` cpp
#include <iostream>
using namespace std;
class Complex
{
    private:
        float real,image;
    public:
        Complex(float r=0,float i=0);
        friend Complex operator+( const Complex &, const Complex &);//函数声明：参数名可写可不写,函数定义：参数名必须写
        friend Complex operator-( const Complex &, const Complex &);
        void Show(int i);
};
Complex::Complex(float r,float i)
{
    real=r;  image=i;
}
void Complex::Show(int i)
{
    cout<<"复数:c"<<i<<"="<<real;
    if(image>0)
        cout<<"+"<<image<<"i"<<endl;
    if(image<0)
        cout<<image<<"i"<<endl;
}
Complex operator+( const Complex &c1, const Complex &c2)
{
    Complex t;
    t.real=c1.real+c2.real;
    t.image=c1.image+c2.image;
    return t;
}
Complex operator-( const Complex &c1, const Complex &c2)
{
    Complex t;
    t.real=c1.real-c2.real;
    t.image=c1.image-c2.image;
    return t;
}
int main()
{
    Complex c1(12,35),c2(20,46),c3,c4;
    c1.Show(1);
    c2.Show(2);
    c3=c1+c2;
    c3.Show(3);
    c4=c1-c2;
    c4.Show(4);
    return 0;
}

```
### 重载流插入和流提取运算符
istream 和 ostream 是 C++ 的预定义流类，cin 是 istream 的对象，cout 是 ostream 的对象。运算符 `<<` 由ostream 重载为插入操作，运算符 `>>` 由 istream 重载为提取操作， 用于输出和输入基本类型数据。可用重载 `<<` 和 `>>` 运算符 ，用于输出和输入用户自定义的数据类型，必须定义为类的友元函数

输出符重载：  
``` ostream & operator << (ostream &,const 自定义类 &);```  
第一个参数和函数的类型都必须是ostream&类型，第二个参数是对要进行输出的类类型的引用，它可以是const，因为一般而言输出一个对象不应该改变对象。返回类型是一个ostream引用，通常是输出操作符所操作的ostream对象。  

输入符重载：  
```istream & operator >> (istream &, 自定义类 &);```  
与输出操作符类似，输入操作符的第一个形参是一个引用，指向要读的流，并且返回的也是同一个流的引用。第二个形参是对要读入的对象的非const 引用，该形参必须为非const，因为输入操作符的目的是将数据读到这个对象中。和输出操作符不同的是输入操作符必须处理错误和文件结束的可能性。  

### 类型重载
将一种类类型对象转换成另一种类类型的对象，类型转换函数必须由用户在类中定义为成员函数，其一般格式为：  
```cpp
class <类名1>
{
  public:
     operator <类名2>( );
     //……
};
<类名1>::operator <类名2>()
{     函数体； }
```
其中operator <类名2>为转换函数的函数名，转换函数的作用是将类型1的对象转换成类型2的对象。类中类型转换函数必须是非静态的成员函数，不能定义成友元函数，无返回值类型且不带参数。  

### new和delete重载
size_t:专门用来表示大小和下标的无符号整数类型  
new通过malloc()实现，delete通过free()实现  

### 逗号运算符重载
```cpp
#include <iostream.h>
#include<malloc.h>

class point
{
   private:
       int x, y ;
   public:
       point( ){ } ;
       point( int xx, int yy )
      {  x=xx ;  y=yy ;  }
     point operator , (point r)
	 {
	     return r ;
	 } 
     point operator + (point r)
	 {
         point t ;
         t.x=x + r.x ;
         t.y=y + r.y ;
	     return  t ;
	 }
	 void disp( )
	  { cout<<"area: "<<x*y<<endl ; }
} ;
void main( )
{
    point  p1(1, 2), p2(3, 4), p3(5, 6) ;
    p1.disp( ) ;
    p2.disp( ) ;
    p3.disp( ) ;
    p1=(p1, p2+p3, p3) ;	//返回右操作数p3的坐标
    p1.disp( ) ;
}
//程序运行结果为：	area: 2
//		area: 12
//		area: 30
//		area: 30
```

### 重载转换运算符
```operator 类型名 () ;```
没有返回值,功能类似强制转换

## 模版与STL
### 定义概念
通过`#define`定义宏；函数重载；函数模版  

模板——是类（结构）或者操作进行类型参数化后的样板，是C++实现代码重用机制的一种工具；模板的声明——由关键字template声明，模板描述了一个类或函数的通用形式，编译器以类型参数化来进行支持；  

函数模版：操作不同类型的对象  
类模板：表示一组类（称为模版类）  

模版的定义
```cpp
template<typename T1,typename T2,...>
返回类型 函数名(参数表){
    //...
}
```

* 定义模板时，不允许 template 语句与函数模板定义之间有任何其他语句
* 函数模板可以有多个类型参数，但每个类型参数都必须用关键字 class 或typename 限定。此外，模板参数中还可以出现确定类型参数，称为非类型参数
```cpp
template<typename T1,typename T2,typename T3,int T4>
T1 fx(T1 a,T2 b,T3 c){...}
//传递实参时，非类型参数 T4 只能使用常量，如 6
```

* 模版类型关键字class和typename含义相同，与类没有任何关系。建议用 typename ，以示区别
* 必须把模板的声明和定义保存在同一文件中，通常保存在同一头文件中

### 函数模版的实例化
类模板本身不是一个类，仅包含模板定义的源文件不会生成任何代码。当我们要使用这样的模板时，我们应当指明其参数，编译器会根据参数和模板生成出一个实际的类（我们称这个类为对应模板的一个 特化 (specialization)；这个过程叫做模板的 实例化 (instantiation)（对函数模板而言也一样）

模型实例化发生的时机：  
模型实例化发生在【第一次】调用模版函数时  

实例化的方式  

* 隐式实例化：编译器能够判断模板参数类型时，自动实例化函数模板为模板函数
* 显示实例化：编译器不能判断模版参数类型或常量值的会后。需要使用特定数据类型实例化
    * 语法形式`模版名称 ,数据类型,...,常量值,...>(参数)` 其中数据类型提供给类型参数，常量值提供给非类型参数
    * eg:`int i = max<int>(1,'2');`

#### 模版参数
C++ 在实例化函数模板的过程中，只是简单地将模板参数替换成调用实参的类型，并以此生成模板函数，不会进行参数类型的任何转换！

模版参数不匹配的解决方法  

* 在模板调用时进行参数类型的强制转换
    * `cout<<max(double(2),3.2)<<end;`
* 显式指定函数模板实例化的类型参数
    * `cout<<max<int>('a',3)<<endl;`
* 指定多个模板参数

类型与非类型模版参数  

* 函数模版参数可以是类型参数，也可以包括普通的参数  
* 向模版函数传递非类型参数是只能传递常量（不能是a，b；但可以是1,3）
eg:  

```cpp
template<class T>
void sort(T &a,int n){//T是类型参数，n是非类型参数
    //
}
```
* 常可以是整型、枚举型、对象或函数的引用，以及对象、函数或类成员的指针，但不允许用浮点型（或双精度型）、类对象或 void 作为非类型参数

模版参数的作用域  

模板参数遵循普通的作用域范围规则：模板参数的可用范围在其声明之后，直到模板声明或定义结束之前；  
同局部变量一样，模板参数会隐藏外层作用域中声明的相同名称。但与普通函数不同的是，**在模板内不能重用模板参数名**



默认模版参数

* 与函数参数一样，类模板默认参数也只能存在于最后的若干参数中（从右往左写）
* 由于函数模板通常有模板参数推导，因此函数模板的默认参数 不必 只能存在于最后的若干参数中

### 类模板
类模版的成员函数的定义  

在类外定义类模板的成员函数时，语法为什么要写成 `Container<T>` 而不是单纯写 Container，因为Container 是一个 类模板，不是普通类，它必须 实例化某个类型 才是真正的类，比如`Container<int>`才是“具体的类”，Container 本身还只是一个蓝图

方法1：在类模板外定义  
```cpp
template <模版参数列表> //eg: class T,int MAXSIZE
返回类型 类模板名<模版参数名称列表>::成员函数名(参数列表){//eg:T,MAXSIZE

}
```

在类模版中声明成员模版  
```cpp
template<typename T> class Container {
    // ...

    template<typename U>
    Container & operator+=(const Container<U> & rhs);
};

template<typename T>    // for the enclosing class template
template<typename U>    // for the member template
Container<T> & Container<T>::operator+=(const Container<U> & rhs) {
    for (unsigned i = 0; i < size && i < rhs.getSize(); i++) {
        data[i] += rhs[i];
    }
    while (size < rhs.getSize()) {
        data[size] = rhs[size];
        size++;
    }
    return *this;
}
```
### 模型设计中的独特问题
#### 类型推导
模版参数推导（template argument deducation）:  
虽然模板的实例化必须 知道 每个模板参数，但是这并不意味着每个参数都需要由调用者 指定。如果可能，编译器会从函数参数中推断出没有明确给出的模板参数。  
```cpp
// template definition: abs is a function template
template<typename T> T abs(T x) { return x > 0 ? x : -x; }

int main() {
    // instantiates and calls abs<int>(int)
    int x = abs<int>(-1);
    // instantiates and calls abs<double>(double), template argument deduced
    double y = abs<>(-1.0);
    // instantiates and calls abs<float>(float), template argument deduced
    float z = abs(-2.0f);
}
```

* 函数模板推导只能通过函数参数推导模板类型
* 返回值类型不能用来推导模板参数

1.传值模版参数  
传值时：忽略引用,忽略顶层 const / volatile**
```cpp
//形式
template <typename T>
void f(T x);

//eg
int a = 10;
const int ca = 20;
//忽略const
f(a);     // T = int
f(ca);    // T = int
//忽略引用
int& ra = a;
f(ra);    // T = int
```
数组/函数：数组退化为指针
```cpp
int arr[10];
f(arr);
T = int*   // 数组退化为指针
//函数
void g();
f(g);     // T = void (*)()
```

!!! note "左值、右值"
    左值：能取地址，例如  
    ```int a = 10;```  
    左值引用：给一个已有对象起别名，如对前面的a,```int& r1 = a;```，不能绑右值,如```int& r2 = 10;```是不行的  
    右值：临时的，没名字，通常不能取地址，常作为表达式结果，如`10`,`a+1`  
    右值引用：绑定临时对象,如```int&& r = 10;```  
    引入右值引用的核心目的：移动语义（move）
2.左值引用模版参数  
保留const  
数组不退化  
不能接受字面常量和临时变量  
```cpp
//形式
template <typename T>
void f(T& x);

int a = 10;
const int ca = 20;

f(a);     // T = int       → 参数类型 int&
f(ca);    // T = const int → 参数类型 const int&

int arr[10];
f(arr);
//推导为
// T = int[10]
//参数类型 = int (&)[10]
```

3.右值引用   
传左值引用折叠，  
```cpp
//形式
template <typename T>
void f(T&& x);
//传左值
int a = 10;
f(a);
//T = int&
// 参数类型 = int& && → int&

//传const左值
const int ca = 20;
f(ca);
//T = const int&
// 参数类型 = const int&

//传右值
f(10);
//T = int
//参数类型 = int&&
```
#### 内联与常量函数模版
把inline或constexpr放在模版参数列表之后，函数返回类型之前  
eg：  
```cpp
temolate <class T>
inline T min(T a,T b){return(a<b)?a:b;}
```
#### 仿函数应用
实际是类的函数调用运算符函数operator()的重载函数
### STL(Standard Template Library, 标准模板库) 
vector  
v.end()是v最后一个元素的后一个位置
sort  

`auto it = std::find(v.begin(), v.end(), 3);` 返回迭代器  

`int n = std::count(v.begin(), v.end(), 3);` 计数    

`int n = std::count_if(v.begin, v.end(), [](int i) { return i % 4 == 0; });`    

`std::for_each(v.begin(), v.end(), [](int &n){ n *= 2; });`每个乘2  

### 迭代器Iterators
