# introduction&lecture1 Using Objects

++ ， -- 与*（指针）优先级相同，且从右到左执行  

## my first program

```cpp
#include<iostream>
using namespace std;

int main()
{
    cout << "helloword" << endl;
    return 0;
}
```
## 编译、运行

```
g++ hello.cpp -o hello  
./hello  
```

## cin输入
cin 可用于读取字符串输入，但只会读取第一个单词，遇到空格或换行符时停止

## cout输出
```endl``` 是 C++ 标准库中的一个操纵符，用于在输出流中插入一个换行符，并刷新输出缓冲区  
```\n```也会换行，但不会刷新缓冲区  

## string
使用前添加头文件```<string>```

```cpp
# include <iostream>
# include <string>
using namespace std;

int main()
{
    string str1; // 创建一个字符串，并初始化为空字符串
    string str2 = "Hello, World!"; // 使用字符串字面值初始化
    string str3("Hello, C++!"); // 使用构造函数初始化
    string str4(str2); // 使用另一个字符串初始化

    cout << str2 << endl; // 输出: Hello, World!
    cout << str3 << endl; // 输出: Hello, C++!
    cout << str4 << endl; // 输出: Hello, World!

    return 0;
}
```

```cpp
sting str1;
string str2 = "werwerwer";
str1 = str2; //legal
string str3;
str3 = str1 + str2;
str1 += str2;
str1 += "lll";

string(const char *cp,int len);
// cosnt char *p 是指向常量字符的指针，这个构造函数会 从 cp 所指向的内存中，拷贝前 len 个字符，并用它们来构造一个新的 string 对象。
string (str1,1);//输出 we

string(const string& s2, int pos, int len);
//const string& str：要从中截取子串的原字符串。
//pos：开始截取的位置（下标，从 0 开始）。
//len（可选）：要截取的字符数，默认是 npos（即截取到字符串末尾）。len过大，截到末尾
string(str1,1,3);//erw

substr(int pos, int len);
// ubstr是取子串的方法，返回一个新的字符串。
string s1 = str.substr(0, 5); //werwe

find (const string& s);
//const string& s：要查找的子串。
//pos（可选）：从原字符串的哪个位置开始查找（默认从开头）。
//返回值：
//如果找到 → 返回子串在原字符串中的 第一个字符的下标。
//如果找不到 → 返回 string::npos（一个特殊的常量，通常是 -1 的无符号表示）。

int main() {
    string s = "hello world";

    size_t pos1 = s.find("world");    // 查找 "world"
    cout << pos1 << endl;             // 输出 6

    size_t pos2 = s.find("lo");       // 查找 "lo"
    cout << pos2 << endl;             // 输出 3

    size_t pos3 = s.find("abc");      // 没找到
    if (pos3 == string::npos) {
        cout << "Not found" << endl;  // 输出 "Not found"
    }

    return 0;
}

assign(const string& str);
//和=差不多，赋值
//可以从：整个字符串、子串、C 字符串、部分字符、迭代器区间、重复字符 → 生成一个新字符串。
string str;
str.assign("abcdef", 3);
cout << str << endl; // "abc"

string str;
str.assign(5, 'x');
cout << str << endl; // "xxxxx"


insert(int pos, const string& s);
//插入

erase();
//删

append();
//末尾加

replace (int pos, int len, const string& s);
//替换
//pos：替换的起始位置（下标，从 0 开始）。
//len：要删除/替换的字符个数。
//str：要插入的新字符串。
//返回值：对当前字符串的引用（所以可以链式操作）。

```
## getline()
```std::getline(istream& is, std::string& str, char delim = '\n');```  

* is：输入流（常见是 cin 或 ifstream）。
* str：用来存放读入的字符串。
* delim：分隔符，默认是换行符 \n。

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string line;

    cout << "请输入一行文字：" << endl;
    getline(cin, line);  // 读整行（含空格）
    cout << "你输入的是：" << line << endl;

    return 0;
}

//输入：hello world cpp；输出：你输入的是：hello world cpp
```

## string的指针
```cpp
# include <iostream>
# include <string>
using namespace std;

int main()
{
    string s = "Hello";
    string* ps = &s; // 定义一个指向 s 的指针

    cout << "String: " << *ps << endl; // 输出: Hello

    // 使用指针调用字符串的方法
    cout << "Length: " << ps -> length() << endl; // 输出: 5
    cout << "Length: " << *(ps).length() << endl; // 输出: 5

    // 修改字符串内容
    *ps = "Hello, World!";
    cout << "Modified String: " << *ps << endl; // 输出: Hello, World!

    return 0;
}
```

可以将一个 string 指针赋值给另一个 string 指针，使它们指向同一个 string 对象  

## File I/O
通过<fstream> 头文件  

* ifstream：输入文件流（读文件）
* ofstream：输出文件流（写文件）
* fstream：同时支持输入和输出  

ifstream  
```cpp
#include <iostream>
#include <fstream>
#include <string>
using namespace std;

int main() {
    ifstream fin("input.txt");   // 打开文件（默认只读）
    if (!fin) {
        cout << "文件打开失败！" << endl;
        return 1;
    }

    string line;
    while (getline(fin, line)) { // 一行一行读取
        cout << line << endl;
    }

    fin.close(); // 关闭文件
    return 0;
}
```

## 内存分配  
局部静态变量  


!!! note 
    睡着了，没听


## new-delete  
```cpp
Student *1 =new Student[10];
delete r;//删掉第一个
delete[] r;//删掉所有r
```

delete指针完后最好把指针赋为nullptr，因为delete不会改变指针本身的值。  

## reference 引用  
之前写了。
reference的意思可以理解为创建一个别名  

作为函数引用用法  
```cpp
int& y = x;
void f(int& x){};
f(y);
```

the target of a reference must have a location.  
创建引用的对象必须有具体位置  
```cpp
void func(int &)；
func(I * 3); //warning or error!

|引用|指针|
|-----|-----|
|不能为空|可以为空|
|依赖于被引用的对象，必须绑定|不必须绑定|
|不能改变被绑定的对象|可以改变绑定的对象|
|不能有引用的引用，不能创建指向引用的指针|可以有指针的指针（二级指针）|
|没有指向数组的引用|可以指向数组|

```cpp
int&* p; //illegal
int*& p; //legal
```

## const 常量

```cpp
const int x = 123;
x = 27; //illegal
x++; //illegal

int y = x; //copy const to non-const ok
const int z = y; //ok
```

* 被const修饰的变量作用域不变  
* 默认为internal linkage
    * 如果你希望 const 在多个源文件间共享，就要用 extern。声明为extern会为变量分配内存空间
    * 编译器通常会直接把常量当成字面值常量使用，不会真的在内存里给它分配一个存储位置。

### aggregates 聚合类
```cpp
const int i[] = {1,2,3,4};//编译器只知道这是一个不能被更改的数组，不能帮你修改
float f[i[3]]; //illegal
struct s{inti,j}; 
const S s[] = {{1,2},{3,4}};
double d[s[1].j]; //illegal,依旧不能具体读出来  
```

### 指针和常量
```cpp
char * const q = "abc"; //q是常量
*q = 'c'; //ok
q++; //错，q不能改变

const char *p = "ABCD";
//*p 是一个常量，即指针指向的对象是const
*p = 'b';//error

//const离谁近谁是const

string p1("Fred");
const string* p = &p1;//指针指向的对象是const，与下面等价
string const* p = &p1;

string *const p = &p1;//指针本身是const
```

❌指针声明指向非const，对象const，  
✅指针声明指向const，对象非const  

### const和字符串
```cpp
const char* s = "Hello";
char* s = "Hello";
//以上两种等价,编译器不允许修改
//如果要修改，只能用数组形式写  
s[0] = 'h'; //error
```

可以吧non-const当作const使用，但是反过来不可以（除非做了类型转换）  

```cpp
void f1(const int i){
    i++; //Illegal
}

---

int f3(){
    return 1;
}
const int f4(){
    return 1;
}
int main(){
    const int j = f3();//ok
    int k = f4();//ok。这种例外只存在return可以理解为返回值只是一份拷贝，只是把1这个数值拷贝出来，赋值给k。
}
```

non-const当成const传参-ok  
函数后的修饰符const ------ 表示该成员函数的执 行不会改变类的状态，也就是说不会修改类的数据成员。  

