# class
推荐把属性写成private  

Prototypes声明，把声明写在前面  
usage  

```cpp
class Point
{
    public :
        void init(int x,int y);
        void move(int dx,int dy);
        void print() const;
    
    private :
        int x;
        int y;
};

void Point::init(int ix,iny iy){
    x = ix; y = iy;
}
void Point::move(int dx,int dy){
    x+= dx; y+= dy;
}
void Point::print()consrt{
    cout << x << '' << y << endl;
}
```

## ：：resolver

```cpp
void S::f(){//表示s类里面有一个函数f
    ::f();//如果写S::f();则变成递归调用
    //意思为调用全局的同名函数f
    ::a++;//访问全局变量a
    a--;//访问类里面的
}
//::f()如果变成f()会默认为S::f()，即访问类内的
```
objects = attributes（属性，数据）+services（服务，操作，函数）  

## eg：stash

!!! note
    📚Thinking in Cpp

实现的是容器container的概念，可以理解为数组，但是对container来可以不写死只能存放某种类型(typeless container)，但是实例化后存放的数据类型要保持一致  

初始化的时候数据大小要确定  

放入put()、add()，拿取get()  

Stash is a container that stores objects and can be expanded during running. 可以动态扩容  

Stash2.h,Stash2.cpp,Stash2Test.cpp  
推荐头文件和cpp起一样的名字。 

### Functions in struct
```cpp
//stash.h头文件
strct Stash{
    int size;//size of each space
    int quantity;//Number of storage spaces
    int next;//Next empty space
    //Dynamically allocated array of bytes
    unsigned char* storage;//用于扩容
    //Functions 成员函数
    void initialize(int size);
    void cleanup();
    int add(const void* element);
    int count;
    void inflate(int increase);
};
```
头文件负责声明有哪些函数，函数体写在main  

### Call the functions in a struct
```cpp
Stash a;
a.initialize(10);
```

```.```表示被调用的函数和前面的变量本身有天然的关联关系，告诉编译器对a进行操作  

### this：the hidden parameter  
天然就存在的局部变量，不要声明/定义，可以直接使用  
stash"类内"的函数initialize()```void Stash::initialize(int sz)```可以被认为写成了```void Stash::initialize(Stash*this, int sz)```  
如果要使用函数，```Stash a; a.initialize(10);```,在编译器看来可以认为是```Stash::initialize(&a,10);```  

在一个成员函数类，可以直接使用this。 如果用a这个对象去调用函数，this指向的对象就是a。  

## objects
对象都只是一个变量而已，内存上的一段空间。  

