# class
æ¨èæŠŠå±æ€§å†™æˆprivate  

Prototypeså£°æ˜ï¼ŒæŠŠå£°æ˜å†™åœ¨å‰é¢  
usage  

```cpp
class Point
{
    public :
        void init(int x,int y);
        void move(int dx,int dy);
        void print() const;
    
    private :
        int x;
        int y;
};

void Point::init(int ix,iny iy){
    x = ix; y = iy;
}
void Point::move(int dx,int dy){
    x+= dx; y+= dy;
}
void Point::print()consrt{
    cout << x << '' << y << endl;
}
```

## ï¼šï¼šresolver
è¯´æ˜å‡½æ•°å¯¹åº”çš„ç±»æ˜¯ä»€ä¹ˆ  
```cpp
void S::f(){//è¡¨ç¤ºsç±»é‡Œé¢æœ‰ä¸€ä¸ªå‡½æ•°f
    ::f();//å¦‚æœå†™S::f();åˆ™å˜æˆé€’å½’è°ƒç”¨
    //æ„æ€ä¸ºè°ƒç”¨å…¨å±€çš„åŒåå‡½æ•°f
    ::a++;//è®¿é—®å…¨å±€å˜é‡a
    a--;//è®¿é—®ç±»é‡Œé¢çš„
}
//::f()å¦‚æœå˜æˆf()ä¼šé»˜è®¤ä¸ºS::f()ï¼Œå³è®¿é—®ç±»å†…çš„
```
objects = attributesï¼ˆå±æ€§ï¼Œæ•°æ®ï¼‰+servicesï¼ˆæœåŠ¡ï¼Œæ“ä½œï¼Œå‡½æ•°ï¼‰  

## egï¼šstash

!!! note
    ğŸ“šThinking in Cpp

å®ç°çš„æ˜¯å®¹å™¨containerçš„æ¦‚å¿µï¼Œå¯ä»¥ç†è§£ä¸ºæ•°ç»„ï¼Œä½†æ˜¯å¯¹containeræ¥å¯ä»¥ä¸å†™æ­»åªèƒ½å­˜æ”¾æŸç§ç±»å‹(typeless container)ï¼Œä½†æ˜¯å®ä¾‹åŒ–åå­˜æ”¾çš„æ•°æ®ç±»å‹è¦ä¿æŒä¸€è‡´  

åˆå§‹åŒ–çš„æ—¶å€™æ•°æ®å¤§å°è¦ç¡®å®š  

æ”¾å…¥put()ã€add()ï¼Œæ‹¿å–get()  

Stash is a container that stores objects and can be expanded during running. å¯ä»¥åŠ¨æ€æ‰©å®¹  

Stash2.h,Stash2.cpp,Stash2Test.cpp  
æ¨èå¤´æ–‡ä»¶å’Œcppèµ·ä¸€æ ·çš„åå­—ã€‚ 

### Functions in struct
```cpp
//stash.hå¤´æ–‡ä»¶
strct Stash{
    int size;//size of each space
    int quantity;//Number of storage spaces
    int next;//Next empty space
    //Dynamically allocated array of bytes
    unsigned char* storage;//ç”¨äºæ‰©å®¹
    //Functions æˆå‘˜å‡½æ•°
    void initialize(int size);
    void cleanup();
    int add(const void* element);
    int count;
    void inflate(int increase);
};
```
å¤´æ–‡ä»¶è´Ÿè´£å£°æ˜æœ‰å“ªäº›å‡½æ•°ï¼Œå‡½æ•°ä½“å†™åœ¨main  

### Call the functions in a struct
```cpp
Stash a;
a.initialize(10);
```

```.```è¡¨ç¤ºè¢«è°ƒç”¨çš„å‡½æ•°å’Œå‰é¢çš„å˜é‡æœ¬èº«æœ‰å¤©ç„¶çš„å…³è”å…³ç³»ï¼Œå‘Šè¯‰ç¼–è¯‘å™¨å¯¹aè¿›è¡Œæ“ä½œ  

### thisï¼šthe hidden parameter  
å¤©ç„¶å°±å­˜åœ¨çš„å±€éƒ¨å˜é‡ï¼Œä¸è¦å£°æ˜/å®šä¹‰ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨  
stash"ç±»å†…"çš„å‡½æ•°initialize()```void Stash::initialize(int sz)```å¯ä»¥è¢«è®¤ä¸ºå†™æˆäº†```void Stash::initialize(Stash*this, int sz)```  
å¦‚æœè¦ä½¿ç”¨å‡½æ•°ï¼Œ```Stash a; a.initialize(10);```,åœ¨ç¼–è¯‘å™¨çœ‹æ¥å¯ä»¥è®¤ä¸ºæ˜¯```Stash::initialize(&a,10);```  

åœ¨ä¸€ä¸ªæˆå‘˜å‡½æ•°ç±»ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨thisã€‚ å¦‚æœç”¨aè¿™ä¸ªå¯¹è±¡å»è°ƒç”¨å‡½æ•°ï¼ŒthisæŒ‡å‘çš„å¯¹è±¡å°±æ˜¯aã€‚  

## objects
å¯¹è±¡éƒ½åªæ˜¯ä¸€ä¸ªå˜é‡è€Œå·²ï¼Œå†…å­˜ä¸Šçš„ä¸€æ®µç©ºé—´ã€‚  

## structure of C++ program
* å¤´æ–‡ä»¶.hï¼šdeclarationså£°æ˜
    * åªå†™å£°æ˜ä¸å†™åˆ«çš„
    * extern variableã€‚externå‘Šè¯‰ç¼–è¯‘å™¨è¿™ä¸ªå˜é‡çš„å®šä¹‰ä¸åœ¨æ­¤å¤„
    * æœ€å¥½åœ¨ä¸€ä¸ªå¤´æ–‡ä»¶é‡Œåªå£°æ˜ä¸€ä¸ªclass


```cpp
#ifndef HEADER_FLAG
#define HEADER_FLAG
//é˜²æ­¢å¾ªç¯å¼•ç”¨
// Type declaration
# endif //HEADER_FLAG
//ä¸Šé¢é‚£æ¡æ³¨é‡Šå¢å¼ºå¯è¯»æ€§
```
* .cppï¼šdefinationså®šä¹‰
    * #includeåŒ…å«å¤´æ–‡ä»¶
        * å…ˆé¢„ç¼–è¯‘ï¼ŒåŸåœ°å±•å¼€ã€‚å¤´æ–‡ä»¶ä¼šè¢«copyè¿›æ¥
        * ç¼–è¯‘å™¨ä»¥.cppä¸ºå¤„ç†å•ä½ã€‚åœ¨é“¾æ¥ä¹‹å‰æ¯ä¸ª.cppä¼šè¢«å•ç‹¬å¤„ç†æˆä¸€ä¸ª.o
        * #include"xx.h"è¡¨ç¤ºç¼–è¯‘å™¨ä¼šé¦–å…ˆåœ¨æºæ–‡ä»¶ï¼ˆ.cppï¼‰æ‰€åœ¨çš„ç›®å½•é‡Œå¯»æ‰¾å¤´æ–‡ä»¶
        * ```#include<xx.h>```åœ¨ç³»ç»ŸæŒ‡å®šçš„å…ˆæ‰¾
        * åœ¨ç‰¹å®šçš„ç›®å½•é‡Œæ‰¾ g++ main.c -l ./include: specify extra directories to search in

## the makfile utility
å®šä¹‰æ–‡ä»¶ä¹‹é—´çš„ä¾èµ–å…³ç³»  

æœ‰å‘æ— ç¯å›¾  

```cpp
//ä¾èµ–å…³ç³»dependecy
main: main.o func1.o func2.o extern_var.o
//å‘½ä»¤action
    g++ main.o func1.o func2.o extern_var.o -o main //æ¨èå’Œå†’å·å‰ä¸€æ ·
//-cè¡¨ç¤ºåªç”Ÿæˆ.oæ–‡ä»¶ï¼Œä¸éœ€è¦åšé“¾æ¥
main.o: main.cpp func1.h func2.h
    g++ -c main.cpp

func1.o: func1.cpp func1.h extern_var.h
    g++ -c func1.cpp

func2.o: func2.cpp func2.h extern_var.h
    g++ -c func2.cpp

extern_var.o: extern_var.cpp extern_var.h
    g++ -c extern_var.cpp
```

```main.o: main.h```åŒåçš„main.cppå¯ä»¥çœç•¥  

ä¸€äº›åˆ«çš„ç¬¦å·ï¼Œ```@```,```$*```ç­‰ ä½†æ˜¯æ‡’å¾—å†™äº†å˜»å˜»  



