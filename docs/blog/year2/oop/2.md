# class
推荐把属性写成private  

Prototypes声明，把声明写在前面  
usage  

```cpp
class Point
{
    public :
        void init(int x,int y);
        void move(int dx,int dy);
        void print() const;
    
    private :
        int x;
        int y;
};

void Point::init(int ix,iny iy){
    x = ix; y = iy;
}
void Point::move(int dx,int dy){
    x+= dx; y+= dy;
}
void Point::print()consrt{
    cout << x << '' << y << endl;
}
```

## ：：resolver
说明函数对应的类是什么  
```cpp
void S::f(){//表示s类里面有一个函数f
    ::f();//如果写S::f();则变成递归调用
    //意思为调用全局的同名函数f
    ::a++;//访问全局变量a
    a--;//访问类里面的
}
//::f()如果变成f()会默认为S::f()，即访问类内的
```
objects = attributes（属性，数据）+services（服务，操作，函数）  

## eg：stash

!!! note
    📚Thinking in Cpp

实现的是容器container的概念，可以理解为数组，但是对container来可以不写死只能存放某种类型(typeless container)，但是实例化后存放的数据类型要保持一致  

初始化的时候数据大小要确定  

放入put()、add()，拿取get()  

Stash is a container that stores objects and can be expanded during running. 可以动态扩容  

Stash2.h,Stash2.cpp,Stash2Test.cpp  
推荐头文件和cpp起一样的名字。 

### Functions in struct
```cpp
//stash.h头文件
strct Stash{
    int size;//size of each space
    int quantity;//Number of storage spaces
    int next;//Next empty space
    //Dynamically allocated array of bytes
    unsigned char* storage;//用于扩容
    //Functions 成员函数
    void initialize(int size);
    void cleanup();
    int add(const void* element);
    int count;
    void inflate(int increase);
};
```
头文件负责声明有哪些函数，函数体写在main  

### Call the functions in a struct
```cpp
Stash a;
a.initialize(10);
```

```.```表示被调用的函数和前面的变量本身有天然的关联关系，告诉编译器对a进行操作  

### this：the hidden parameter  
天然就存在的局部变量，不要声明/定义，可以直接使用  
stash"类内"的函数initialize()```void Stash::initialize(int sz)```可以被认为写成了```void Stash::initialize(Stash*this, int sz)```  
如果要使用函数，```Stash a; a.initialize(10);```,在编译器看来可以认为是```Stash::initialize(&a,10);```  

在一个成员函数类，可以直接使用this。 如果用a这个对象去调用函数，this指向的对象就是a。  

## objects
对象都只是一个变量而已，内存上的一段空间。  

## structure of C++ program
* 头文件.h：declarations声明
    * 只写声明不写别的
    * extern variable。extern告诉编译器这个变量的定义不在此处
    * 最好在一个头文件里只声明一个class


```cpp
#ifndef HEADER_FLAG
#define HEADER_FLAG
//防止循环引用
// Type declaration
# endif //HEADER_FLAG
//上面那条注释增强可读性
```
* .cpp：definations定义
    * #include包含头文件
        * 先预编译，原地展开。头文件会被copy进来
        * 编译器以.cpp为处理单位。在链接之前每个.cpp会被单独处理成一个.o
        * #include"xx.h"表示编译器会首先在源文件（.cpp）所在的目录里寻找头文件
        * ```#include<xx.h>```在系统指定的先找
        * 在特定的目录里找 g++ main.c -l ./include: specify extra directories to search in

## the makfile utility
定义文件之间的依赖关系  

有向无环图  

```cpp
//依赖关系dependecy
main: main.o func1.o func2.o extern_var.o
//命令action
    g++ main.o func1.o func2.o extern_var.o -o main //推荐和冒号前一样
//-c表示只生成.o文件，不需要做链接
main.o: main.cpp func1.h func2.h
    g++ -c main.cpp

func1.o: func1.cpp func1.h extern_var.h
    g++ -c func1.cpp

func2.o: func2.cpp func2.h extern_var.h
    g++ -c func2.cpp

extern_var.o: extern_var.cpp extern_var.h
    g++ -c extern_var.cpp
```

```main.o: main.h```同名的main.cpp可以省略  

一些别的符号，```@```,```$*```等 但是懒得写了嘻嘻  



