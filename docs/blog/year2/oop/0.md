# cpp学习
来自菜鸟教程  

## 基本操作、基础知识
### 编译&执行  

* 假设有一个hello.cpp
* 键入```g++ hello.cpp```，编译代码，没错误则跳到下一行，并生成a.out可执行文件,键入```./a.out```来运行程序
* 或者键入```g++ hellp.cpp -o hello1```,再键入```./hello1```来运行，-o后面的文件名默认是a.out，可以自己写

编译多个文件
```
g++ main.cpp support.cpp -o write
./writr
```

### 数据类型  

* int4字节，long int8字节
* auto 自动类型判断，如```auto x = 10;```
* decltype 获取表达式的类型，如```decltype(x) y = 10;```decltype(x) = “x 的类型”。
* nullptr 空指针常量
* std::initializer_list 初始化列表类型
* std::tuple 元组类型
* typedef 为现有类型定义别名，如```typedef int MyInt;```
* using 为现有类型定义别名（c++11），如```using MyInt = int;```

枚举类型  
```cpp
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;

//如果枚举没有初始化, 即省掉"=整型常数"时, 则从第一个标识符开始。
//例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 "blue"。

enum color { red, green, blue } c;
c = blue;

//默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。
enum color { red, green=5, blue };
//在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。
```

### 类型转换  
1.静态转换  
将一种数据类型的值强制转换为另一种数据类型的值。  

```cpp
double d = 3.14;
int i = static_cast<int>(d);  // i = 3

int i = 10;
float f = static_cast<float>(i); // 静态将int类型转换为float类型
```

2.动态转换  
动态转换（dynamic_cast）是 C++ 中用于在继承层次结构中进行向下转换（downcasting）的一种机制。  
动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。  
动态转换在运行时进行类型检查。如果转换失败，对于指针类型会返回 nullptr，对于引用类型则会抛出 std::bad_cast 异常。 

```cpp
class Base { public: virtual ~Base(){} };
class Derived : public Base {};
Base* b = new Base;
Derived* d = dynamic_cast<Derived*>(b); // 转换失败，d = nullptr
```

3.常量转换  
只能将const类型的对象转换为非const类型的对象  

```cpp
const int i = 10;
int& r = const_cast<int&>(i); // 常量转换，将const int转换为int
```

4.重新解释转换  
将一个数据类型的值重新解释为另一个数据类型的值  
== 没搞懂，回头再看 ==  

5.?强制类型转换Cast  
int(5.1)=5
### cpp变量作用域
有三个地方可以定义变量：局部变量、形式参数（函数参数的定义中声明的变量）、全局变量  
变量的作用域：局部作用域（函数内部）、全局作用域、块作用域（代码块内部）、类作用域  
如果在内部作用域中生命的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部  

系统不会对局部变量初始化，但会自动初始化全局变量。int-0，char-'\0'，float-0，double-0，pointer-NULL  

### 定义常量
```#define```预处理器  

```cpp
#define identifier value
```
const关键字  
```cpp
const type variable = value;
```

### 修饰符、存储类
|限定符|含义|
|------|-------|
|const|常量，默认具有static存储期|  
|restrict|由它修饰的指针是唯一一种访问其所指的对象的方式|
|mutable|用于修饰类的成员变量，被修饰的可以被修改，即时对象是const的|
|static|定义静态变量，该变量的作用域仅限于当前文件或当前函数内，生命周期贯穿整个程序的运行期|
|extern|用于声明具有外部链接的变量或函数，它们可以在多个文件之间共享，全局变量和函数默认extern|

```cpp
#include <iostream>
 
// 函数声明 
void func(void);
 
static int count = 10; /* 全局变量 */
 
int main()
{
    while(count--)
    {
       func();
    }
    return 0;
}
// 函数定义
void func( void )
{
    static int i = 5; // 局部静态变量
    i++;
    std::cout << "变量 i 为 " << i ;
    std::cout << " , 变量 count 为 " << count << std::endl;
}
```

输出结果：
```
变量 i 为 6 , 变量 count 为 9
变量 i 为 7 , 变量 count 为 8
变量 i 为 8 , 变量 count 为 7
变量 i 为 9 , 变量 count 为 6
变量 i 为 10 , 变量 count 为 5
变量 i 为 11 , 变量 count 为 4
变量 i 为 12 , 变量 count 为 3
变量 i 为 13 , 变量 count 为 2
变量 i 为 14 , 变量 count 为 1
变量 i 为 15 , 变量 count 为 0
```

### 运算

|类别|运算符|结合性|
|--------|---------|-----------| 
|后缀|() [] -> . ++ --|从左到右| 
|一元 |+ - ! ~ ++ - - (type)* & sizeof|从右到左| 
|乘除 |* / % |从左到右| 
|加减|+ - |从左到右| 
|移位|<< >> |从左到右| 
|关系|< <= > >=|从左到右| 
|相等|== != |从左到右| 
|位与| &|从左到右| 
|位异或| ^ |从左到右| 
|位或| \| |从左到右| 
|逻辑与|&&|从左到右| 
|逻辑或|\|\||从左到右|
|条件|?: |从右到左| 
|赋值|= += -= *= /= %=>>= <<= &= ^= \|= |从右到左| 
|逗号| 	, |从左到右| 

### 函数
参数：传值调用、指针调用、引用调用  
默认值  

lambda函数与表达式
```cpp
[capture](parameters) -> return_type { body }
```

```[caputre]```：捕获列表  
```
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```

!!! note"引用捕获"
    在 Lambda 内部，直接使用外部变量 x 的引用。外面改 x，Lambda 里看到的也会跟着变。
    ```cpp
    int a = 10;
    auto f = [&a]() { return a; };

    a = 20;
    cout << f() << endl;  // 输出 20（因为捕获的是引用）
    ```

```(parameters)```参数列表  
和普通函数一样，定义传入参数。  

```-> return_type``` 返回类型（可省略）  

```{ body }```函数体  

对于```[=]```或```[&]```的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：```[this]() { this->someFunc(); }();```

!!! note"this"
    this 是 一个隐含在成员函数中的指针，它指向调用该成员函数的对象本身。  
    还没学，之后补  

### 数学
先引入头文件```<cmath>```
```int abs(int)``` 返回任意一个浮点数的绝对值  
```double fabs(double)``` 返回任意一个浮点数的绝对值  

随机数  
```rand()```返回一个伪随机数，生成之前先调用```sand()```函数，需要头文件```<cstdlib>```  
实际使用```time()```来获取系统时间的秒数
```cpp
#include <iostream>
#include <ctime>
#include <cstdlib>
 
using namespace std;
 
int main ()
{
   int i,j;
 
   // 设置种子
   srand( (unsigned)time( NULL ) );
 
   /* 生成 10 个随机数 */
   for( i = 0; i < 10; i++ )
   {
      // 生成实际的随机数
      j= rand();
      cout <<"随机数： " << j << endl;
   }
 
   return 0;
}
```

### 数组、指针
c语言记了，之后有再补充  
[菜鸟教程-数组](https://www.runoob.com/cplusplus/cpp-arrays.html){:target="_blank"}  
[菜鸟教程-指针](https://www.runoob.com/cplusplus/cpp-pointers.html){:target="_blank"} 

### 字符串
c风格的字符串  
数组，'\0'结尾 
加入头文件```<cstring>```  

|函数|目的|
|------|--------|
|strcpy(s1,s2)|把s2复制到s1（会把str原有的覆盖掉）|
|strcat(s1,s2)|连接字符串s2到s1的末尾，也可以用+|
|strcmp(s1,s2)|如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。|
|strchr(s1, ch)|返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。|
|strstr(s1, s2)|返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。|

c++中的string类  
学类和对

### 引用  
引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。  

```cpp
int a = 10;
int *p = &a; //p是a的指针
int &ref = a;  // ref 是 a 的引用
double& s = d;

//以上写法本质都是(int&) i = a;

int &a = x, &b = y;  // ✅ 正确，两者都是 int& 引用
```

与指针相比  

* 不存在空引用，必须初始化，但可以有空指针
* 不能重新绑定
* 引用的对象必须是一个变量，而指针必须是一个地址
* 没有引用的引用，不支持多级间接访问

引用用于函数参数和指针差不多  

引用用于返回值
```cpp
#include <iostream>
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues(int i) {  
   double& ref = vals[i];    
   return ref;   // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]
 
 
}
 
// 要调用上面定义函数的主函数
int main ()
{
 
   cout << "改变前的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
 
   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素
 
   cout << "改变后的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
   return 0;
}
```

```
改变前的值
vals[0] = 10.1
vals[1] = 12.6
vals[2] = 33.1
vals[3] = 24.1
vals[4] = 50
改变后的值
vals[0] = 10.1
vals[1] = 20.23
vals[2] = 33.1
vals[3] = 70.8
vals[4] = 50
```

```cpp
//当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。
int& func() {
   int q;
   //! return q; // 在编译时发生错误
   static int x;
   return x;     // 安全，x 在函数作用域外依然是有效的
}
```

### 时间和日期
头文件```<ctime>```

### 输入输出
标准输出流cout  
标准输入流cin  
标准错误流cerr  
标准日志流clog  

### 结构体
```cpp
struct type_name {
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
} object_names;
```

指向结构的指针  
```struct Books *struct_pointer;```   

```cpp
struct_pointer = &Book1;
//指向 Books 结构体的指针 struct_pointer。
struct_pointer->title;
//为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符

```  

struct 默认的成员和继承是 public。  
class 默认的成员和继承是 private。  

### vector容器
vector 是 动态数组（可变长数组），位于 ```<vector> ```头文件。和普通数组不同，vector 会自动管理内存，支持动态增长和缩减。
特点：

* 连续存储（和数组一样，元素在内存中连续存放）
* 随机访问快（O(1) 下标访问）
* 在末尾插入/删除效率高（摊还 O(1)）
* 在中间插入/删除效率较低（O(n)）

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // 创建一个空的 vector，存 int
    vector<int> v;

    // 添加元素
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);

    // 访问元素,可以使用下标操作符 [] 或 at() 方法访问 vector 中的元素：
    cout << v[0] << " " << v.at(1) << endl; // 10 20

    // 遍历
    for (auto it = myVector.begin(); it != myVector.end(); ++it) {
    std::cout << *it << " ";
    }//可以使用迭代器遍历 vector 中的元素
    for (int x : v) cout << x << " ";  // 范围 for
    cout << endl;

    // 大小,可以使用 size() 方法获取 vector 中元素的数量
    cout << "size = " << v.size() << endl;

    // 删除最后一个元素
    v.pop_back();

    // 插入/删除指定位置
    v.insert(v.begin() + 1, 15);   // 在索引 1 插入 15
    v.erase(v.begin());            // 删除第一个元素
}
```

```cpp
std::vector<int> myVector(5); // 创建一个包含 5 个整数的 vector，每个值都为默认值（0）
std::vector<int> myVector(5, 10); // 创建一个包含 5 个整数的 vector，每个值都为 10
std::vector<int> vec; // 默认初始化一个空的 vector
std::vector<int> vec2 = {1, 2, 3, 4}; // 初始化一个包含元素的 vector
```

### 数据结构
之后再写吧  

## 类、对象
定义类  

```cpp
class classname
{

    Access specifiers: //访问修饰符：private/public/private
        Data members/variables;//变量类型
        Member functions(){}//方法
};

//eg:
class Box
{
   public:
      double length;   // 盒子的长度
      double breadth;  // 盒子的宽度
      double height;   // 盒子的高度
};
Box Box1;          // 声明 Box1，类型为 Box
Box Box2;          // 声明 Box2，类型为 Box
```

类的对象的公共数据成员可以使用直接成员访问运算符 . 来访问。  
私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问.

### 类成员函数
成员函数可以定义在类定义内部，或者单独使用范围解析运算符 :: 来定义。  

```cpp
class Box
{
   public:
      double length;      // 长度
      double breadth;     // 宽度
      double height;      // 高度
   
      double getVolume(void)
      {
         return length * breadth * height;
      }//定义在内部
};

double Box::getVolume(void)
{
    return length * breadth * height;
}//在类的外部使用范围解析运算符 :: 定义该函数
```

```cpp
//eg
#include <iostream>
 
using namespace std;
 
class Box
{
   public:
      double length;         // 长度
      double breadth;        // 宽度
      double height;         // 高度
 
      // 成员函数声明
      double getVolume(void);
      void setLength( double len );
      void setBreadth( double bre );
      void setHeight( double hei );
};
 
// 成员函数定义
double Box::getVolume(void)
{
    return length * breadth * height;
}
 
void Box::setLength( double len )
{
    length = len;
}//void表示函数无返回值
 
void Box::setBreadth( double bre )
{
    breadth = bre;
}
 
void Box::setHeight( double hei )
{
    height = hei;
}
 
// 程序的主函数
int main( )
{
   Box Box1;                // 声明 Box1，类型为 Box
   Box Box2;                // 声明 Box2，类型为 Box
   double volume = 0.0;     // 用于存储体积
 
   // box 1 详述
   Box1.setLength(6.0); 
   Box1.setBreadth(7.0); 
   Box1.setHeight(5.0);
 
   // box 2 详述
   Box2.setLength(12.0); 
   Box2.setBreadth(13.0); 
   Box2.setHeight(10.0);
 
   // box 1 的体积
   volume = Box1.getVolume();
   cout << "Box1 的体积：" << volume <<endl;
 
   // box 2 的体积
   volume = Box2.getVolume();
   cout << "Box2 的体积：" << volume <<endl;
   return 0;
}
```

### 类访问修饰符
#### public公有成员
公有成员在程序中类的外部是可访问的。
#### private私有成员
私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。默认情况下，类的所有成员 **都是私有的。**   
一般来说将函数设置为public便于类外访问和修改，将数据定义为private  

```cpp
#include <iostream>
 
using namespace std;
 
class Box
{
   public:
      double length;
      void setWidth( double wid );
      double getWidth( void );
 
   private:
      double width;
};
 
// 成员函数定义
double Box::getWidth(void)
{
    return width ;
}
 
void Box::setWidth( double wid )
{
    width = wid;
}
 
// 程序的主函数
int main( )
{
   Box box;
 
   // 不使用成员函数设置长度
   box.length = 10.0; // OK: 因为 length 是公有的
   cout << "Length of box : " << box.length <<endl;
 
   // 不使用成员函数设置宽度
   // box.width = 10.0; // Error: 因为 width 是私有的
   box.setWidth(10.0);  // 使用成员函数设置宽度
   cout << "Width of box : " << box.getWidth() <<endl;
 
   return 0;
}
```

#### protected 受保护成员
与私有成员十分相似，但是protected成员在派生类（子类）是可访问的 ,private 成员只能被本类成员（类内）和友元访问，不能被派生类访问。  

```cpp
#include <iostream>
using namespace std;
 
class Box
{
   protected:
      double width;
};
 
class SmallBox:Box // SmallBox 是派生类
{
   public:
      void setSmallWidth( double wid );
      double getSmallWidth( void );
};
 
// 子类的成员函数
double SmallBox::getSmallWidth(void)
{
    return width ;
}
 
void SmallBox::setSmallWidth( double wid )
{
    width = wid;
}
 
// 程序的主函数
int main( )
{
   SmallBox box;
 
   // 使用成员函数设置宽度
   box.setSmallWidth(5.0);
   cout << "Width of box : "<< box.getSmallWidth() << endl;
 
   return 0;
}
```

### 类构造函数&解析构造函数

!!! note
    emm

## 我也不知道起什么标题
### map
map是C++ 标准库里的一个容器，定义在命名空间 std 下。  
```std::map<std::string, double> scores;```  

std::map 就像一个“字典”，里面是一对一对的键值,它把键映射到值（key-value）：  
键 (key)：唯一的，比如课程名 "aaa"、"bbb"；  
值 (value)：与键对应的数据，比如分数 4.5。  

常用操作  

|操作|eg|说明|
|---------|---------|----------|
|插入、修改|```scores["math"] = 90;```|若不存在则添加；若存在则更新|
|访问|```cout << scores["math"];```|输出math对应的分数|
|判断是否存在|```if(scores.count("Math"))```|判断是否有math课程|
|遍历| ```for (auto &p :scores)cout<< p.first << p.seconds```|遍历键值对|
|删除|```scores.srase("math");```|删除指定key|

### vector
* 动态数组：大小可变，可以像数组一样通过索引访问元素。
* 元素在内存中连续存储。
* 常用头文件：#include <vector>
* 命名空间：std::vector

| 操作| 示例 | 说明 |
| ---- |----------- | -------- |
| 添加元素 | `v.push_back(10);` | 在末尾加元素   |
| 删除末尾 | `v.pop_back();`   | 删除最后一个元素   |
| 获取大小 | `v.size();`  | 返回元素个数 |
| 访问元素 | `v[0]` 或 `v.at(0)`     | `[]` 不检查越界，`at()` 检查越界 |
| 清空   | `v.clear();`    | 删除所有元素 |
| 遍历   | `for(auto x:v) cout<<x;` 或 `for(int i=0;i<v.size();i++)` | 两种常用方式  |
| 插入   | `v.insert(v.begin()+1, 100);` | 在指定位置插入元素 |
| 删除   | `v.erase(v.begin()+1);` | 删除指定位置元素  |

```cpp
//排序
#include <algorithm>
sort(v.begin(), v.end()); // 升序
sort(v.begin(), v.end(), greater<int>()); // 降序


//二维vector
vector<vector<int>> mat(3, vector<int>(4, 0)); // 3行4列，初值0

```
### set
* 集合容器：存储唯一元素，自动排序。
* 元素不重复。
* 底层一般是红黑树（平衡二叉搜索树）。
* 常用头文件：#include <set>

| 操作   | 示例   | 说明       |
| ---- | -------------- | -------- |
| 插入元素 | `s.insert(5);`  | 自动去重 |
| 删除元素 | `s.erase(2);`  | 删除值为2的元素|
| 查找元素 | `if(s.count(3)) ...` 或 `s.find(3)` | 判断是否存在|
| 获取大小 | `s.size()` | 元素数量 |
| 遍历   | `for(auto x:s) cout<<x;` | 按升序输出|

```cpp
//迭代器遍历
for(auto it = s.begin(); it != s.end(); ++it) {
    cout << *it << " ";
}

//排序
set<int, greater<int>> s; // 降序排列

//范围操作
auto it1 = s.lower_bound(2); // >=2 的第一个元素
auto it2 = s.upper_bound(5); // >5 的第一个元素
s.erase(it1, it2); // 删除区间
```

### sstream
stringstream 是 C++ ```<sstream> ```头文件里的类，属于 字符串流（string stream），它把一个 std::string 当作输入/输出流来处理，就像对待 cin 或 cout 一样，非常适合解析格式化的字符串。  

std::stringstream：既可以读也可以写的字符串流  
std::istringstream：只读的字符串流。  
std::ostringstream：只写的字符串流。  

`>>` 操作符按空格分割，和 cin 一样  
```cpp
#include <sstream>
#include <string>
#include <iostream>
using namespace std;

int main() {
    string str = "123 45.6 hello";
    stringstream ss(str); // 将 str 放入字符串流

    int a;
    double b;
    string c;

    ss >> a >> b >> c;   // 按空格逐个读取
    cout << a << " " << b << " " << c << endl; // 123 45.6 hello
}
```


|方法|说明|
|------|------|
|`ss.str()`|获取或设置流中的字符串|
|`ss.clear()`|重置流状态（例如 eof、fail 标志）|
|`ss << value`|向流中写入数据|
|`ss >> value`|从流中读取数据|
|`ss.str("new string")`|重新初始化流的内容|
|`ss.seekg(pos) `|设置读位置|
|`ss.seekp(pos)`|设置写位置|
