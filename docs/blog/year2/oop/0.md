# cpp学习
来自菜鸟教程  

## 基本操作、基础知识
### 编译&执行  

* 假设有一个hello.cpp
* 键入```g++ hello.cpp```，编译代码，没错误则跳到下一行，并生成a.out可执行文件,键入```./a.out```来运行程序
* 或者键入```g++ hellp.cpp -o hello1```,再键入```./hello1```来运行，-o后面的文件名默认是a.out，可以自己写

编译多个文件
```
g++ main.cpp support.cpp -o write
./writr
```

### 数据类型  

* int4字节，long int8字节
* auto 自动类型判断，如```auto x = 10;```
* decltype 获取表达式的类型，如```decltype(x) y = 10;```decltype(x) = “x 的类型”。
* nullptr 空指针常量
* std::initializer_list 初始化列表类型
* std::tuple 元组类型
* typedef 为现有类型定义别名，如```typedef int MyInt;```
* using 为现有类型定义别名（c++11），如```using MyInt = int;```

枚举类型  
```cpp
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;

//如果枚举没有初始化, 即省掉"=整型常数"时, 则从第一个标识符开始。
//例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 "blue"。

enum color { red, green, blue } c;
c = blue;

//默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。
enum color { red, green=5, blue };
//在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。
```

### 类型转换  
1.静态转换  
将一种数据类型的值强制转换为另一种数据类型的值。  

```cpp
double d = 3.14;
int i = static_cast<int>(d);  // i = 3

int i = 10;
float f = static_cast<float>(i); // 静态将int类型转换为float类型
```

2.动态转换  
动态转换（dynamic_cast）是 C++ 中用于在继承层次结构中进行向下转换（downcasting）的一种机制。  
动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。  
动态转换在运行时进行类型检查。如果转换失败，对于指针类型会返回 nullptr，对于引用类型则会抛出 std::bad_cast 异常。 

```cpp
class Base { public: virtual ~Base(){} };
class Derived : public Base {};
Base* b = new Base;
Derived* d = dynamic_cast<Derived*>(b); // 转换失败，d = nullptr
```

3.常量转换  
只能将const类型的对象转换为非const类型的对象  

```cpp
const int i = 10;
int& r = const_cast<int&>(i); // 常量转换，将const int转换为int
```

4.重新解释转换  
将一个数据类型的值重新解释为另一个数据类型的值  
== 没搞懂，回头再看 ==  

5.?强制类型转换Cast  
int(5.1)=5
### cpp变量作用域
有三个地方可以定义变量：局部变量、形式参数（函数参数的定义中声明的变量）、全局变量  
变量的作用域：局部作用域（函数内部）、全局作用域、块作用域（代码块内部）、类作用域  
如果在内部作用域中生命的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部  

系统不会对局部变量初始化，但会自动初始化全局变量。int-0，char-'\0'，float-0，double-0，pointer-NULL  

### 定义常量
```#define```预处理器  

```cpp
#define identifier value
```
const关键字  
```cpp
const type variable = value;
```

### 修饰符、存储类
|限定符|含义|
|------|-------|
|const|常量，默认具有static存储期|  
|restrict|由它修饰的指针是唯一一种访问其所指的对象的方式|
|mutable|用于修饰类的成员变量，被修饰的可以被修改，即时对象是const的|
|static|定义静态变量，该变量的作用域仅限于当前文件或当前函数内，生命周期贯穿整个程序的运行期|
|extern|用于声明具有外部链接的变量或函数，它们可以在多个文件之间共享，全局变量和函数默认extern|

```cpp
#include <iostream>
 
// 函数声明 
void func(void);
 
static int count = 10; /* 全局变量 */
 
int main()
{
    while(count--)
    {
       func();
    }
    return 0;
}
// 函数定义
void func( void )
{
    static int i = 5; // 局部静态变量
    i++;
    std::cout << "变量 i 为 " << i ;
    std::cout << " , 变量 count 为 " << count << std::endl;
}
```

输出结果：
```
变量 i 为 6 , 变量 count 为 9
变量 i 为 7 , 变量 count 为 8
变量 i 为 8 , 变量 count 为 7
变量 i 为 9 , 变量 count 为 6
变量 i 为 10 , 变量 count 为 5
变量 i 为 11 , 变量 count 为 4
变量 i 为 12 , 变量 count 为 3
变量 i 为 13 , 变量 count 为 2
变量 i 为 14 , 变量 count 为 1
变量 i 为 15 , 变量 count 为 0
```

### 运算

|类别|运算符|结合性|
|--------|---------|-----------| 
|后缀|() [] -> . ++ --|从左到右| 
|一元 |+ - ! ~ ++ - - (type)* & sizeof|从右到左| 
|乘除 |* / % |从左到右| 
|加减|+ - |从左到右| 
|移位|<< >> |从左到右| 
|关系|< <= > >=|从左到右| 
|相等|== != |从左到右| 
|位与| &|从左到右| 
|位异或| ^ |从左到右| 
|位或| \| |从左到右| 
|逻辑与|&&|从左到右| 
|逻辑或|\|\||从左到右|
|条件|?: |从右到左| 
|赋值|= += -= *= /= %=>>= <<= &= ^= \|= |从右到左| 
|逗号| 	, |从左到右| 

### 函数
参数：传值调用、指针调用、引用调用  
默认值  

lambda函数与表达式
```cpp
[capture](parameters) -> return_type { body }
```

```[caputre]```：捕获列表  
```
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```

!!! note"引用捕获"
    在 Lambda 内部，直接使用外部变量 x 的引用。外面改 x，Lambda 里看到的也会跟着变。
    ```cpp
    int a = 10;
    auto f = [&a]() { return a; };

    a = 20;
    cout << f() << endl;  // 输出 20（因为捕获的是引用）
    ```

```(parameters)```参数列表  
和普通函数一样，定义传入参数。  

```-> return_type``` 返回类型（可省略）  

```{ body }```函数体  

对于```[=]```或```[&]```的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：```[this]() { this->someFunc(); }();```

!!! note"this"
    this 是 一个隐含在成员函数中的指针，它指向调用该成员函数的对象本身。  
    还没学，之后补  

### 数学
先引入头文件```<cmath>```
```int abs(int)``` 返回任意一个浮点数的绝对值  
```double fabs(double)``` 返回任意一个浮点数的绝对值  

随机数  
```rand()```返回一个伪随机数，生成之前先调用```sand()```函数，需要头文件```<cstdlib>```  
实际使用```time()```来获取系统时间的秒数
```cpp
#include <iostream>
#include <ctime>
#include <cstdlib>
 
using namespace std;
 
int main ()
{
   int i,j;
 
   // 设置种子
   srand( (unsigned)time( NULL ) );
 
   /* 生成 10 个随机数 */
   for( i = 0; i < 10; i++ )
   {
      // 生成实际的随机数
      j= rand();
      cout <<"随机数： " << j << endl;
   }
 
   return 0;
}
```

### 数组、指针
c语言记了，之后有再补充  
[菜鸟教程-数组](https://www.runoob.com/cplusplus/cpp-arrays.html){:target="_blank"}  
[菜鸟教程-指针](https://www.runoob.com/cplusplus/cpp-pointers.html){:target="_blank"} 

### 字符串
c风格的字符串  
数组，'\0'结尾 
加入头文件```<cstring>```  

|函数|目的|
|------|--------|
|strcpy(s1,s2)|把s2复制到s1（会把str原有的覆盖掉）|
|strcat(s1,s2)|连接字符串s2到s1的末尾，也可以用+|
|strcmp(s1,s2)|如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。|
|strchr(s1, ch)|返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。|
|strstr(s1, s2)|返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。|

c++中的string类  
学类和对

### 引用  
引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。  

```cpp
int a = 10;
int &ref = a;  // ref 是 a 的引用
double& s = d;

//以上写法本质都是(int&) i = a;

int &a = x, &b = y;  // ✅ 正确，两者都是 int& 引用
```

与指针相比  

* 不存在空引用，必须初始化，但可以有空指针
* 不能重新绑定
* 引用的对象必须是一个变量，而指针必须是一个地址
* 没有引用的引用，不支持多级间接访问

引用用于函数参数和指针差不多  

引用用于返回值
```cpp
#include <iostream>
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues(int i) {  
   double& ref = vals[i];    
   return ref;   // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]
 
 
}
 
// 要调用上面定义函数的主函数
int main ()
{
 
   cout << "改变前的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
 
   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素
 
   cout << "改变后的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
   return 0;
}
```

```
改变前的值
vals[0] = 10.1
vals[1] = 12.6
vals[2] = 33.1
vals[3] = 24.1
vals[4] = 50
改变后的值
vals[0] = 10.1
vals[1] = 20.23
vals[2] = 33.1
vals[3] = 70.8
vals[4] = 50
```

```cpp
//当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。
int& func() {
   int q;
   //! return q; // 在编译时发生错误
   static int x;
   return x;     // 安全，x 在函数作用域外依然是有效的
}
```

### 时间和日期
头文件```<ctime>```

### 输入输出
标准输出流cout  
标准输入流cin  
标准错误流cerr  
标准日志流clog  

### 结构体
```cpp
struct type_name {
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
} object_names;
```

指向结构的指针  
```struct Books *struct_pointer;```   

```cpp
struct_pointer = &Book1;
//指向 Books 结构体的指针 struct_pointer。
struct_pointer->title;
//为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符

```  

struct 默认的成员和继承是 public。  
class 默认的成员和继承是 private。  

### vector容器
vector 是 动态数组（可变长数组），位于 ```<vector> ```头文件。和普通数组不同，vector 会自动管理内存，支持动态增长和缩减。
特点：

* 连续存储（和数组一样，元素在内存中连续存放）
* 随机访问快（O(1) 下标访问）
* 在末尾插入/删除效率高（摊还 O(1)）
* 在中间插入/删除效率较低（O(n)）